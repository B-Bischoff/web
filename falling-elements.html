<!DOCTYPE HTML>
<!--
Phantom by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
	<title>Falling-elements</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-CP7YYY7WEF"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'G-CP7YYY7WEF');
	</script>
</head>
<body class="is-preload">
	<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
				<header id="header">
					<div class="inner">

						<!-- Logo -->
							<a href="index.html" class="logo">
								<span class="symbol"><img src="images/Square-grey.png" alt="" /></span><span class="title">Page principale</span>
							</a>

						<!-- Nav -->
							<nav>
								<ul>
									<li><a href="#menu">Menu</a></li>
								</ul>
							</nav>

					</div>
				</header>

			<!-- Menu -->
				<nav id="menu">
					<h2>Menu</h2>
					<ul>
						<li><a href="index.html">Projets</a></li>
						<li><a href="a-propos.html">À propos</a></li>
						<li><a href="contact.html">Contact</a></li>
					</ul>
				</nav>

			<!-- Main -->
				<div id="main">
					<div class="inner">
						<h1>Falling elements</h1>
						<span class="image main"><img src="images/photo-tile-4.png" alt="" /></span>

						<h2>Contexte</h2>
						<p>
							Le but de ce projet personnel est de refaire un des jeux de type "Falling-sand" que l'on peut retrouver en ligne.<br>
							Ces jeux laissent l'utilisateur interagir avec différents éléments, qui peuvent produire de nombreuses réactions entre eux.
							Comme le jeu ne possède pas de but à proprement parler, on appelle ce genre "bac à sable", car il permet au joueur de faire tout ce qu'il souhaite, sans aucune contrainte.
						</p>
						<p>
							Ce type de jeu se base généralement sur un moteur utilisant des particules dans un tableau en deux dimensions.<br>
							Le plus connu de ce genre étant le Jeu de la vie de John Horton Conway.<br>
							On retrouve cependant des versions bien plus récentes et poussées comme avec le jeu Noita, sorti en 2019.
						</p>
						<p>
							Pour réaliser ce projet j'utiliserai le langage C++ couplé à OpenGL pour la partie graphique.
						</p>
						<hr>
						<h2>Sommaire</h2>
						<ul>
							<li><a href="#grille">Afficher une grille avec OpenGL</a></li>
							<li><a href="#cellules">Concevoir les cellules et leurs caractéristiques</a></li>
							<li><a href="#mise-a-jour">Actualiser les cellules</a></li>
							<li><a href="#comportements">Créer différents comportements</a></li>
							<li><a href="#conclusion">Conclusion</a></li>
							<li><a href="#sources">Sources</a></li>
						</ul>

						<h2>Réalisation</h2>
						<h3 id="grille">Afficher une grille avec OpenGL</h3>
						<p>
							L'avantage de ne pas utiliser un moteur de jeu préfait comme dans de précédents projets avec Unity, est de pouvoir faire une application sur mesure.
							Seul les éléments nécessaires au projet seront présents, ce qui permet d'améliorer la taille du projet et ses performances.<br>
							En revanche, toutes les fonctionnalités pouvant se trouver dans un moteur préfait sont à reprogrammer, augmentant le travail à fournir.
						</p>
						<p>
							Comme ici le seul objectif est de pouvoir afficher des couleurs sur une grille, il est acceptable de se passer d'un moteur de jeu existant.
						</p>
						<p>
							OpenGL utilise des triangles pour afficher des couleurs sur notre écran.
							Il faut donc lui fournir les trois points qui constituent chaque triangle, ainsi que leurs couleurs.<br>
							On va alors parler de "vertex". Chaque vertex, va contenir une position ainsi qu'une couleur.
						</p>
						<p>
							Une fois les vertex définies, il faut indiquer quels vertex relier entre eux en précisant leurs indices.<br>
							Voici un schéma illustrant comment afficher un carré.
							<br><b>SCHEMA VERTEX 1, 2, 3, 4 ET INDICES (1,2,3) (3,4,1)</b>
						</p>
						<p>
							C'est en appliquant ce principe pour plusieurs carrés qu'il est possible de refaire à la main, une grille où chaque carré peut changer de couleur.<br>
						</p>
						<br><b>IMAGES/VIDEOS RESULTATS</b>
						<p>
							Cependant, plus le nombre d'éléments dans la grille est grand, plus l'affichage mettra du temps à s'effectuer.
							Pour pallier à ce soucis, il est possible d'utiliser la technique du "batch rendering".<br>
							Au lieu d'afficher chaque triangle un par un, le batch rendering va regrouper un grand nombre de surface à afficher et toutes les traiter en même temps.<br>
							Bien sûr, cette technique n'est pas magique est ne fonctionne pas pour une infinité de surfaces.
							Elle permet cependant de rendre fluide l'affiche d'une centaine de millier de carrés, ce qui est difficilement réalisable sans cette technique.
						</p>
						<p>
							Actuellement les couleurs affichées par la grille sont définies à la main.
							La prochaine étape est de créer la base qui va permettre de donner vie à cette grille de couleurs.
						</p>

						<h3 id="cellules">Concevoir les cellules et leurs caractéristiques</h3>
						<p>
							Il est donc temps de créer ces fameux "éléments".
							Chaque élément possèdera un ensemble de règles leurs permettant permettant de reproduire un comportement désiré.
						</p>
						<p>
							Commençons par définir de quoi seront composées ces cellules.<br>
							Etant donné que la grille vient d'être réalisée, il parait essentiel que chaque cellule possède une couleur.<br>
							Il est également primordial d'avoir une position. Cette position sera utile pour savoir où se situe la cellule dans la grille en deux dimensions.<br>
							Pour différencier les différents états de matières, les cellules possèderont un type correspondant à "solide", "liquid" ou "gazeux".
						</p>
						<p>
							Viens, ensuite la question de comment définir ces fameux comportements ?<br>
							Une solution serait d'utiliser le système d'héritage du langage C++, afin de créer différents types de cellules (solides, liquides, gazeuses).
							Et à partir de ces grands groupes, il serait ensuite possible de sous-diviser ces grands types pour créer des éléments de manière plus précise.
							Par exemple dans les solides, d'avoir des cellules, roches, sable, terre, etc...<br>
							La deuxième solution se sert du principe de composition.
							En programmation orientée objet, la composition est le fait d'avoir une instance d'une classe dans une autre.
							Chaque cellules possèderaient alors un objet, correspondant à un des différents comportements programmé.
						</p>
						<p>
							Dans l'optique de généraliser au maximum les cellules, il est préférable d'opter pour la composition.<br>
							Celles-ci devraient être définies par ce qui les composent, et non pas par une hiérarchisation entre différentes classes.<br>
							Cela permet d'avoir de nouveaux types de cellules, tirants leurs propriétés de différents types existant, favorisant ainsi la création de comportements émergeant.
						</p>
						<p>
							Il est à noter que les cellules ne possèdent pour l'instant que peu de caractéristiques, mais de nouvelles en seront rajoutées au fur et à mesure que le projet avance.
						</p>
						<p>
							Pour utiliser son comportement, il faut qu'une cellule sache quelle méthode appeller et ce, quel que soit le comportement qu'elle possède.<br>
							Autrement dit, le nom de la méthode doit rester le même malgré ses différentes implémentations possibles.
						</p>
						<p>
							Utiliser le système d'interface du langage C++ est donc très pratique pour créer différents types de comportements.<br>
							Une interface permet de désigner un ensemble de fonctionnalités sans implémentation.
							Ces fonctionnalités seront uniquement définies par les classes dérivées.
						</p>

						<b>MONTRER HEADER IMOVEMENT BEHAVIOR (?)</b>

						<p>
							Toutes les cellules doivent posséder un membre <i>IThermicBehavior</i></p>.
							La méthode<code>update</code>permet à chaque cellule d'utiliser sa fonction de mouvement implémentée par une classe héritant de <i>IMovementBehavior</i>.
						</p>
						<p>
							Pour commencer à implémenter un premier comportement de déplacement, le sable est idéal car son fonctionnement est simple.<br>
							En grande quantité, le sable doit former des dunes.
							Pour cela il doit non seulement subir l'effet de la gravité mais également celui du glissement lorsqu'il est en pente.<br>
							Ces conditions appliquées à notre grille en deux-dimensions se résument avec ce schéma.
						</p>

						<b>SCHEMA ALGO SABLE</b>

						<blockquote>
							<p><b>Précisions techniques</b></p>
							<p>
								Pour que le comportement d'une cellule puisse modifier les informations de celle-ci (par exemple sa position),
								il est nécessaire de lui fournir une référence de la cellule à sa création.<br>
								Il en est de même pour le tableau de cellules.
								Pour que le comportement puisse analyser les cellules voisines, il faut qu'il ait un accès au tableau et à ses dimensions.
							</p>
						</blockquote>

						<p>
							Voici le code correspondant au comportement du sable.
						</p>

						<pre>
							<code>
void SandMovement::update()
{
	_target = nullptr; // Cell pointer
	_x = _cell->getPosition().x;
	_y = _cell->getPosition().y;

	if (_y < _cell->getHeight() - 1) // Don't check out of arrays bounds
	{
		checkBelowCell();

		if (targetFound() == false)
		{
			_random = (rand() % 2) * 2 - 1; // Randomly generate +1 or -1
			checkAdjacentBelowCells();
		}

		if (targetFound() == true)
			_cell->swapCell(*_target);
	}
}
							</code>
						</pre>

						<p>
							La première étape sert à récupérer la position de la cellule actuelle mais également à initialiser la cellule "cible" comme non-trouvée.<br>
							Après avoir fait attention à ce que la cellule ne soit pas déjà tout en bas de la grille, le comportement vérifie si la cellule juste en dessous peut servir de cible.
							Si ce n'est pas le cas, il vérifie ensuite les cellules en bas à droite et gauche (dans un autre aléatoire).<br>
							Enfin, si une des cellules scrutée remplie toutes les conditions, celle-ci sera intervertie avec la cellule actuelle.
						</p>
						<p>
							Voici la définition des méthodes utilisées par le code précédent.
						</p>
						<pre>
							<code>
void SandMovement::checkBelowCell()
{
	if (_cells[_y + 1][_x].getType() < CellType::Solid)
		_target = &(_cells[_y + 1][_x]);
}

void SandMovement::checkAdjacentBelowCells()
{
	int x1 = _x + _random;
	int x2 = _x - _random;

	if (x1 >= 0 && x < _cell->getWidth() && _cells[_y + 1][x1].getType() < CellType::Solid)
		_target = &(_cells[_y + 1][x1]);
	else if (x2 >= 0 && x2 < _cell->getWidth() && _cells[_y + 1][x2].getType() < CellType::Solid)
		_target = &(_cells[_y + 1][x2]);
} const bool SandMovement::targetFound()
{
	return _target != nullptr;
}
							</code>
						</pre>

						<p>
							Pour qu'une cellule soit une cible valide, il faut que son type soit "inférieur" à celui de la cellule actuelle, autrement dit, inférieur au type "solide".<br>
							C'est l'utilisation des énumérations de C++ qui rend l'opération inférieur possible.
							La première valeur a avoir été déclarée dans l'énumération est l'état "gazeux", cette valeur est donc associée à la valeur numérique 0.
							Suivant le même principe, l'état "liquide"  est associée à un et l'état "solide" à deux.
						</p>

						<p>
							Au lancement de l'application, toutes les cellules seront par défaut de type "gazeuse" et auront un mouvement les rendant statiques.<br>
							Voici une démonstration vidéo du comportement de mouvement implémenté à l'instant.
						</p>

						<b>VIDEO SABLE AVEC MAUVAISE UPDATE<br></b>

						<p>
							Le sable possède le comportement attendu mais il y a quelque chose de surprenant dans cette démonstration.<br>
							Impossible de le voir tomber, dès que celui-ci est placé, il tombe instantanément au sol.
						</p>

						<h3 id="mise-a-jour">Actualiser les cellules</h3>

						<p>
							Ce problème vient de la manière dont les cellules sont actualisée.<br>
							Actuellement, pour chaque actualisation le programme va parcourir toutes les cellules et déclencher leur méthode <code>update</code>.
							Pour parcourir les cellules, le programme commence par la position (0, 0) qui est en haut à gauche et va se diriger vers la fin de la ligne avant de passer à la suivante.<br>
							Cependant si une cellule se déplace, elle risque de se faire actualiser plus d'une fois par le programme.
						</p>

						<b>VIDEO (SCHEMA) CELLULE ACTU PLUSIEURS FOIS<br></b>

						<p>
							Il y a plusieurs solutions pour pallier à ce soucis<br>
							La première consiste à mettre à jour les cellules en commençant par le bas.
							Impossible pour les cellules qui tombent de se faire mettre à jour plusieurs fois.
							En revanche le problème sera le même pour des mouvements faisant aller les cellules vers le haut.
						</p>
						<p>
							Une deuxième solution serait de ne pas effectuer de changement sur le tableau en cours avant d'avoir mis à jour toutes les cellules.
							Cette technique requiert un second tableau, (doublant la taille de notre programme à son éxécution).
							De plus, il y a des risques de conflits dans le cas où deux cellules devraient se déplacer au meme endroit.<b>PHOTO CONFLIT</b>
						</p>
						<p>
							La dernière possibilité consiste à vérifier si la cellule à déjà été actualisée et de continuer à itérer sur le tableau,
							tant que toutes les cellules n'ont pas été mises à jour.<br>
							Loin d'être la plus optimisée l'avantage de cette technique est sa simplicité de mise en place.
							Il suffit de rajouter un booléen aux cellules qui est vérifiée avant de mettre à jour la cellule.
							Une fois toutes les cellules actualisées, leur booléen est remis à zéro.
						</p>

						<b>VIDEO CELLULE NICE ACTU SAUF HORIZONTAL (SABLE TOMBE DU MEME COTE)<br></b>

						<p>
							Le résultat est bien mieux que précédemment.
							Il y a cependant un comportement étrange lorsque le sable est remplacé par du vide.<br>
							Le sable plus en hauteur s'affaisse toujours du même côté.
							A savoir le côté gauche.
						</p>
						<p>
							Le problème vient encore une fois de la manière dont sont mises à jour les cellules.
							Malgré le fait qu'il n'y ait plus de multiples actualisation pour une même cellule, le programme actualise toujours les cellules de gauche à droite et ligne par ligne.<br>
							Ainsi, pour obtenir un résultat un peu plus chaotique, il faut actualiser toutes les cellules de la même ligne dans un ordre aléatoire.<br>
						</p>
						<p>
							Plutôt que de générer une séquence aléatoire à chaque mise à jour de l'application (ce qui serait très couteuk), il est possible d'en créer une multitude au lancement du programme,
							et d'alterner entre ces différentes séquences à chaque mise à jour.
						</p>

						<p>
							Chaque séquence sera contenue dand un tableau dynamique (vecteur de C++) et toutes les séquences seront stockées dans un tableau.<br>
							Voici le code pour générer un nombre N de séquences contenant des nombres allant de 0 à la largeur de la grille.
						</p>

						<pre>
							<code>
void Application::generateRandomSets(const int& N)
{
	_randomSets = new std::vector<int>[N];

	for (int i = 0; i < N; i++) // For each set
		for (int j = 0; j < CELL_WIDTH; j++) // Fill with numbers from 0 to CELL_WIDTH
			_randomSets[i].push_back(j);

	// Shuffle numbers in sets
	auto rng = std::default_random_engine {};
	for (int i = 0; i < N; i++)
		std::shuffle(_randomSets[i].begin(), _randomSets[i].end(), rng);
}
							</code>
						</pre>

						<p>
							Cette méthode va d'abord remplir tous les vecteurs avec les nombres dans l'ordre.
							Puis avec l'usage de la librairie standard, elle va ensuite mélanger le contenu afin d'avoir une multitude de séquences aléatoires.<br>
							Ainsi au lieu de parcourir les cellules de gauche à droite, il faut maintenant utiliser les nombres de la séquence actuelle en tant qu'indice.
						</p>
						<p>
							Voici maintenant le morceau de code permettant de mettre à jour toutes les cellules.
						</f>

						<pre>
							<code>
size_t cellsUpdated = 0;
while (cellsUpdated < CELL_HEIGHT * CELL_WIDTH)
{
	for (int y = 0; y < CELL_HEIGHT; y++)
	{
		for (int x = 0; x < CELL_WIDTH; x++)
		{
			// Retrieve x position from current set
			int xPos = _randomSets[_currentRandomSet].at(x);

			// If cell was not already updated
			if (_cells[y][xPos].update())
				cellsUpdated += 1;
		}
		// Update set
		_currentRandomSet = (_currentRandomSet + 1) % RANDOM_SETS_NB;
	}
}
							</code>
						</pre>

						<p>
							Au lieu de prendre comme position la variable<code>x</code>allant de zéro à CELL_WIDTH,
							on récupère la valeur stockée à l'indice<code>x</code> dans la séquence de nombres aléatoires.<br>
						</p>

						<b>VIDEO SABLE BON ERASE</b>

						<p>
							Comme voulu, le résultat est plus chaotique, rendant le comportement du sable un peu plus intéressant.
						</p>
						<p>
							Jusqu'à présent il y a eu beaucoup de mise en place du "moteur".<br>
							Le résultat actuel n'est certes, pas le plus optimisé, néanmoins il est pleinement fonctionnel et ne subira plus de modifications majeures .<br>
							Le champ est maintenant libre pour se concentrer profondeur sur les différents matériaux ainsi que leurs comportement.
						</p>

						<h3 id="comportements">Créer différents comportements</h3>

						<p>
							Pour créer le premier liquide, quoi de mieux que de commencer par l'eau.<br>
							Il est important de rappeler ici que le but n'est pas de reproduire le plus fidèlement possible des comportements mais de les simuler de manière simple et amusante.
							Autrement, à lui seul, le domaine de la dynamique des fluides aurait pu être un projet.
						</p>
						<p>
							Les mouvements de l'eau reprennent ceux du sable.
							On souhaite qu'elle puisse subir la gravité et couler en pente.
							Cependant, elle doit en plus former une surface plane lorsqu'elle à fini de s'écouler.<br>
							Ansi, en plus de pouvoir de se déplacer vers les trois cellules sous elle, elle doit être capable de bouger sur les cellules à sa gauche et à sa droite.
						</p>

						<b>SCHEMA MOUVEMEMT EAU (BAS + GAUCHE & DROITE)<br></b>

						<pre>
							<code>
void WaterMovement::update()
{
	_target = nullptr; // Cell pointer
	_x = _cell->getPosition().x;
	_y = _cell->getPosition().y;

	if (_y < _cell->getHeight() - 1) // Don't check out of arrays bounds
	{
		checkBelowCell();

		_random = (rand() % 2) * 2 - 1; // Randomly generate +1 or -1

		if (targetFound() == false)
			checkAdjacentBelowCells();
	}

	if (targetFound() == false)
		checkAdjacentCells();

	if (targetFound() == true)
		_cell->swapCell(*_target);
}
							</code>
						</pre>

						<p>
							Le code est très similaire à celui des mouvements du sable vu précémment, si ce n'est pour l'appel de la nouvelle méthode<code>checkAdjacentCells</code>.<br>
						</p>
						<pre>
							<code>
void WaterMovement::checkAdjacentCells()
{
	int x1 = _x + _random;
	int x2 = _x - _random;

	if (x1 >= 0 && x < _cell->getWidth() && _cells[_y][x1].getType() < CellType::Liquid)
		_target = &(_cells[_y][x1]);
	else if (x2 >= 0 && x2 < _cell->getWidth() && _cells[_y][x2].getType() < CellType::Liquid)
		_target = &(_cells[_y][x2]);
}
							</code>
						</pre>
						<p>
							Afin d'éviter de dupliquer du code, il est possible de créer plusieurs fonctions appartenants à l'interface<code>IMovementBehavior</code>.
							Ces fonctions pourront ainsi être réutilisée par toutes les classes qui vont hériter de l'interface.
						</p>
						<p>
							Voici une vidéo du résultat avec l'eau conçue telle que décrite ci-dessus.
						</p>

						<b>VIDEO EAU SIMPLE<br></b>

						<p>
							L'eau tend bien vers un niveau plat, cependant elle met beaucoup de temps à s'étaler.<br>
							Une solution assez simple pour accélérer ce phénomène consiste à vérifier ses possibilités de déplacements horizontaux sur plusieurs cellules.
							Si il y a plusieurs espaces vides (autrement dit, des cellules de types gazeuses),
							elle échangerait sa position avec une cellule plus loin, permettant ainsi de se déplacer plus vite pour le même nombre d'actualisation.
						</p>

						<p>
							La simple utilisation d'une boucle permet d'implémenter cette idée.<br>
							Dans le code suivant, l'eau ira chercher à se déplacer horizontalement sur cinq cellules.
						</p>

						<pre>
							<code>
void WaterMovement::checkAdjacentCells()
{
	const int CHECK_LENGTH = 5;

	for (int i = 1; i < CHECK_LENGTH; i++)
	{
		int x1 = _x + i * _random;
		if (x1 >= 0 && x < _cell->getWidth() && _cells[_y][x1].getType() < CellType::Liquid)
			_target = &(_cells[_y][x1]);
		else
			break;
	}

	if (targetFound())
		return;

	for (int i = 1; i < CHECK_LENGTH; i++)
	{
		int x2 = _x - i * _random;
		if (x2 >= 0 && x2 < _cell->getWidth() && _cells[_y][x2].getType() < CellType::Liquid)
			_target = &(_cells[_y][x2]);
		else
			break;
	}
}
							</code>
						</pre>

						<p>
							Pour ne pas traverser de cellules, il est important de sortir de la boucle (instruction<code>break</code>dans le programme)
							dès qu'une cellule ne remplie pas les conditions pour être une cible.
						</p>
						<p>
							On constate sur la vidéo ci-dessous qu'une différence est notable, d'une part à cause le vitesse d'écoulement,
							mais également à l'aide de ces petites "éclaboussures" qui apparaissent quand l'eau s'équilibre.
						</p>

						<b>VIDEO EAU AVEC HORIZONTAL LOOP CHECK<br></b>

						<p>
							Le comportement de l'eau commence à devenir complet et intéressant, en revanche, celui du sable paraît un peu plus léger.<br>
							Pourquoi ne pas essayer de le compléter en ajoutant un semblant de vitesse ?
						</p>
						<p>
							Une première application de vélocité serait pendant la chute d'une cellule.
							En chute libre, une cellule accumulerait une certaine viteses puis la dépenserait à l'impacte.<br>
							Pour symboliser une vitesse, il est nécessaire de rajouter une caractéristique aux cellules.
							Le choix a été de fait prendre un vecteur en deux dimensions (provenant de la <i><a href="https://github.com/g-truc/glm">librairie mathématiques GLM</a></i>).<br>
							L'utilisation d'un vecteur en deux dimensions permet de représenter la vitesse et la direction en même temps.<br>
							La composante x du vecteur sera utilisée pour la vitesse sur l'axe horizontal et y, pour l'axe vertical.
							Un vecteur de valeur x: 1 et y: -1 signifie que la cellule se dirigera vers la droite et également vers le haut (car la coordonnée 0, 0 du tableau se trouve en haut à gauche de l'écran)
							L'usage de vitesse négative signifie donc que la cellule se déplace dans le sens contraire de l'axe.
						</p>
						<p>
							Plus concrètement, la vitesse d'une cellule va impacter son comportement lors de la recherche d'un possible mouvement.<br>
							A la manière dont l'eau cherchait à se déplacer horizontalement sur cinq cellules, le sable va chercher à se déplacer sur plusieurs cellules sous lui.
							Cependant, la distance de recherche sera determinée par sa vitesse verticale.
						</p>

						<pre>
							<code>
void SandMovement::checkBelowCell()
{
	for (int i = 0; i < _cell->getVelocity().y; i++)
	{
		if (_y + 1 + i < _cell->getHeight() && _cells[_y + 1 + i][_x].getType() < CellType::Solid)
			_target = &(_cells[_y + 1 + i][_x]);
		else
			break;
	}
}
							</code>
						</pre>

						<p>
							A chaque unité de vélocité supplémentaire, la distance de vérification augmentera de un.<br>
							Dans la méthode<code>update</code>se trouve une nouvelle méthode, <code>udpateVelocity</code>ayant pour rôle de modifier la vitesse
							de la cellule actuelle, dépendant du type de la cellule avec laquelle celle-ci va changer de place.<br>
							Dans l'exemple suivant, la vitesse de chaque cellule va augmenter de 0.2 unité en chute libre mais va en perdre 0.8 en coulant dans un liquide.
						</p>

						<pre>
							<code>
void SandMovement::update()
{
		// ... (previous code did not change)

		if (targetFound() == true)
		{
			updateVelocity();
			_cell->swapCell(*_target);
		}
	}
}

void SandMovement::updateVelocity()
{
	if (_target->getType() == CellType::Gazeous) // Accelerate in free falling
		_cell->setVelocity(_cell->getVelocity() + glm::vec2(0.0f, 0.20f));
	else if (_target->getType() == CellType::Liquid && _cell->getVelocity().y >= 0.80f) // Get slow done by liquid
		_cell->setVelocity(_cell->getVelocity() + glm::vec2(0.0f, -0.80f));
}
							</code>
						</pre>

						<p>
							La prochaine vidéo présente les effets du code montré.
						</p>

						<b>VIDEO SABLE FREE FALLING + SLOW DOWN WATER</b>

						<p>
							Le sable prend bien de la vitesse en chute libre et se fait bel et bien ralentir par l'eau lorsqu'il entre en collision avec.<br>
							La question qui se pose alors, est, que faire de la vitesse accumulée une fois que la cellule est au sol ?
							La réponse va alors dépendre de jusqu'où veut-on pousser la simulation.<br>
							Il est possible de transmettre sa vitesse aux cellules voisines à l'impacte.
							C'est d'ailleurs ce qui a été brièvement fait (sans franc succès) dans l'application finale, cependant ce sujet ne sera pas couvert sur cette page.<br>
							<b>INTRO RELACHEMENT ENERGIE ACCUMULEE --> PARTICULES</b>
						</p>

						<h3 id="conclusion">Conclusion</h3>
						<h3 id="sources">Sources</h3>

						<hr>
						<h2>Conclusion</h2>

						<h2 id="sources">Sources</h2>
						<h2>Téléchargement</h2>
						<ul class="actions">
						<li><a href="https://github.com/B-Bischoff/cube3d" class="button icon brands fa-github">Code source + éxécutable</a></li>
						</ul>
					</div>
				</div>

				<!-- Footer -->
				<footer id="footer">
					<div class="inner">
						<ul class="copyright">
							<li>Design adapté depuis une création : <a href="http://html5up.net">HTML5 UP</a></li>
							<li>Ce site utilise Google Analytics</li>
						</ul>
					</div>
				</footer>

		</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>

	</body>
</html>
