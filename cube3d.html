<!DOCTYPE HTML>
<!--
Phantom by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
	<title>Cube3d</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-CP7YYY7WEF"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-CP7YYY7WEF');
	</script>
</head>
<body class="is-preload">
	<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
				<header id="header">
					<div class="inner">

						<!-- Logo -->
							<a href="index.html" class="logo">
								<span class="symbol"><img src="images/Square-grey.png" alt="" /></span><span class="title">Page principale</span>
							</a>

						<!-- Nav -->
							<nav>
								<ul>
									<li><a href="#menu">Menu</a></li>
								</ul>
							</nav>

					</div>
				</header>

			<!-- Menu -->
				<nav id="menu">
					<h2>Menu</h2>
					<ul>
						<li><a href="index.html">Projets</a></li>
						<li><a href="a-propos.html">A propos</a></li>
						<li><a href="contact.html">Contact</a></li>
					</ul>
				</nav>

			<!-- Main -->
				<div id="main">
					<div class="inner">
						<h1>Cube3d</h1>
						<span class="image main"><img src="images/cube3d/background-1.png" alt="" /></span>

						<h2>Contexte</h2>
						<b>Sujet 42<br>Objectifs</b>
						<hr>

						<h2>Réalisation</h2>



						<h3>Librairie graphique</h3>
						<p>
							Le sujet impose l'utilisation de la librairie graphique : MiniLibX.<br>
							<b>PRECISER OS<br></b>
							Cette librairie offre la possibilité de créer une fenêtre, gérer différents types d'évènements ou encore dessiner sur des images.<br>
						</p>

						<h4>Création d'une fenêtre</h4>
						<p>
							Voici la manière la plus simple de créer une fenêtre à partir de la MiniLibX.<br>
							La fonction <i>mlx_init</i> renvoie un pointeur qui indique où se trouve l'instance de la mlx dans la mémoire. Le rôle de cette instance, est d'établir une connexion entre notre programme et l'environnement graphique de l'ordinateur.<br>
							La fonction <i>mlx_new_window</i> permet de définir la taille de la fenêtre ainsi que le titre de celle-ci.
						</p>
						<pre><code>int main(void)
{
	void *mlx;
	void *mlx_win;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "A simple window");
	mlx_loop(mlx);
}</pre></code>

						<p>
							C'est <i>mlx_loop</i> qui va s'occuper d'actualiser et d'afficher la fenêtre sur notre écran.<br>
							Nous allons dès à présent rendre cette fenêtre un peu plus intéressante en dessinant dessus.
						</p>

						<h4>Utilisation des images</h4>
						<p>
							Il existe la fonction <i>mlx_pixel_put</i> qui permet de placer des pixels sur notre fenêtre, cependant cette fonction extrêmement lente car elle place le pixel et actualise directement l'affichage.<br>
 							Par conséquent, j’ai opté pour un moyen plus optimisé, celui de stocker tous les pixels que l'on souhaite placer (à l'aide d'un buffer), et seulement lorsque tous les pixels sont stockés, la fenêtre met à jour son contenu.
						</p>
						<p>
							Le moyen de stocker les pixels est d'utiliser une image.<br>
							Cela implique de déclarer quelques variables supplémentaires comme :<br>
							<ul>
								<li>Une référence a l'instance de l'image</li>
								<li>L'adresse mémoire de l'image</li>
								<li>Le nombre de bits que chaque pixel occupe</li>
								<li>La taille en mémoire qu'occupe une ligne de l'image</li>
								<li>Une indication de quel boutiste (endian en anglais) utiliser</li>
							</ul>
						</p>

						<pre><code>typedef struct s_data {
	void *img;
	char *addr;
	int bits_per_pixel;
	int line_length;
	int endian;
} t_data;

int main(void)
{
	void *mlx;
	t_data img;

	mlx = mlx_init();
	img.img = mlx_new_image(mlx, 1920, 1080);
	img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);
}</code></pre>
						<p>
							Notre image (ici de dimension 1920 par 1080 pixels) est créée grâçe à la fonction <i>mlx_new_image</i><br>
							Les informations supplémentaires décrites précédemment sont assignées par la fonction <i>mlx_get_data_addr</i>.
						</p>

						<h4>Écriture sur une image</h4>
						<p>
							Le dernier élément manquant est un moyen de placer des pixels sur notre image.<br>
							La fonction suivante permet, à partir d'une coordonnée (x et y), d'écrire une certaine valeur (représentant une couleur) à l'endroit correspondant dans la mémoire de l'image.
						</p>
						<pre><code>void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
	char *dst;

	ddt = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
	*(unsigned int*)dst = color;
}</code></pre>
						<p>
							Les informations de l'image sont ici extrêmement utiles, elles nous permettent de trouver le décalage entre la position de chaque pixel et son emplacement dans la mémoire.<br>
						</p>
						<p>
							Il peut également être utile de vérifier la cohérence des coordonnées en début de fonction. Il se peut autrement que le programme aille chercher des données dans un espacement mémoire ne lui appartenant pas, causant ainsi l'arrêt du programme.
						</p>

						<h4>Affichage de l'image</h4>
						<p>
							Le moment tant attendu arrive, celui où nous allons voir des couleurs sur notre fenêtre !
							A l'aide des notions expliquées jusqu'ici (initialisation d'une fenêtre et d'une image ainsi que la structure <i>data</i>) nous allons appeler <i>my_mlx_pixel_put</i> et afficher le contenu de l'image sur notre fenêtre.
						</p>

						<pre><code>int main(void)
{
	void *mlx;
	void *mlx_win;
	t_data img;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "A simple window");
	img.img = mlx_new_image(mlx, 1920, 1080);
	img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);
	my_mlx_pixel_put(&img, 100, 100, 0x00FF0000);
	mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
	mlx_loop(mlx);
}</code></pre>

						<p>
							Ce petit code a pour effet de placer un pixel rouge (<b>LIEN MLX COLORS</b>) à la coordonnée (en pixels) 100, 100 de notre fenêtre.<br>
							C'est ensuite <i>mlx_put_image_to_window</i> qui va mettre a jour la fenêtre en affichant le contenu de notre image.
						</p>

						<h4>Boucles</h4>
						<p>
							Pour créer un jeu vidéo avec lequel il est possible d'interagir, il est nécessaire d'implémenter ce qu'on appel une "game loop".<br>
							<b>ILLUSTRATION GAME LOOP<br></b>
							Une game loop tourne en continue pendant l'éxécution du jeu. À chaque tour de boucle, le programme lit les entrées de l'utilisateur, met à jour le contenu du jeu puis actualise l'affichage.
						</p>
						<p>Voyons comment implémenter cette boucle a l'aide de la MiniLibX.</p>

						<pre><code>int render_next_frame(void *program_struct);

int main(void)
{
	void *mlx;
	t_struct program_struct;

	mlx = mlx_init();
	mlx_loop_hook(mlx, render_next_frame, &program_struct);
	mlx_loop(mlx);
}</code></pre>
						<p>À chaque frame, la fonction <i>render_next_frame</i> sera appelée avec pour paramètre <i>program_struct</i>.</p>

						<h4>Entrées utilisateur</h4>
						<p>Un jeu vidéo ne serait pas très intéressant sans possibilités d'interaction.</p>
						<p>
							La MiniLibX fournit la possibilité d'intercepter différents type d'évènements.<br>
							Ces évènements (par exemple liés à la souris ou au clavier) ne font qu'appeler une fonction quand ils se déclenchent.<br>
							Plus concrètement, il faut au début du programme, indiquer à la MiniLibX quelles sont les évenèments à écouter, et quelles fonctions vont-ils appeller en conséquence.
						</p>
						<p>
							Les évènements sont représentés par des nombres, voici une liste (minime) des évènements qui nous seront utiles :
							<ul>
								<li>02 : Touche du clavier pressée</li>
								<li>03 : Touche du clavier relâchée</li>
								<li>04 : Clique de souris pressé</li>
								<li>05 : Clique de souris relâché</li>
								<li>06 : Mouvement de la souris</li>
								<li>17 : Appui sur la croix rouge de la fenêtre</li>
							</ul>
						</p>

						<pre><code>int key_press(int keycode, t_struct *program_struct)
{
	printf("Key pressed : %d\n", keycode);
	return (0);
}

int main(void)
{
	void *mlx;
	void *mlx_win;
	t_struct program_struct;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "A simple window");
	mlx_hook(mlx_win, 2, 0, key_press, &program_struct);
	mlx_loop(mlx);
}</code></pre>
						<p>
							Rappelons que les actions effectuées en fonction des entrées utilisateur (par exemple déplacer le personnage du joueur) se font dans la game loop précédemment implémentée.<br>
							Les évènements ne vont donc pas effectuer d'actions sur les données de notre jeu (personnage, carte, interface ou autre), mais uniquement mettre à jour les informations liées a nos contrôles (état des touches du clavier, position du curseur, état des cliques de la souris).
						</p>
						<p>
							Cela implique pour notre programme d'avoir un moyen de stocker les données de nos périphériques.<br>
							Pour le clavier, il est possible de créer un tableau de booléens (du nombre de touches du clavier) et dès qu'une touche est pressée, la case du tableau correspondant à la touche est passée à vrai.
						</p>
						<p>Ainsi, dans notre game loop il ne reste qu'à vérifier si une touche (une case précise du tableau) est appuyée pour effectuer une action.</p>

						<h3>Définition de raycasting</h3>
						<p>
							Notamment connu pour les célèbres Doom et Wolfenstein 3D (dans les années 1990), le raycasting 2D est une technique de calcul d'images permettant de représenter en 3D un univers en 2D.
						</p>

						<h3>Difference entre raycasting et raytracing</h3>
						<p>
							<b>A COMPLETER</b>
						</p>

						<h3>Fondamentaux</h3>

						<b>SPEECH CONCEPT RAYCASTING ?<br></b>

						<h4>Représentation de la carte</h4>
						<p>
							Comme dit précédemment, le raycasting se base sur un univers en deux dimensions (vu du dessus).<br>
							Voyons, pour commencer, comment représenter informatiquement une carte contenant des espaces vides et des murs.
						</p>

						<p>
							Le moyen le plus simple est d'utiliser un tableau a deux dimensions. Chacune de ses cellules aura une valeur que nous pourrons utiliser pour afficher notre monde (par exemple 1 pour un mur ou 0 pour un espace vide).
							Un des désavantage de ce choix est que nous sommes contraint d'avoir un résultat où toutes les surfaces seront quadrillées.
						</p>

						<p>
							Pour faciliter l'accès à nos données, nous utiliserons une structure nommée <i>data</i>. Pour l'instant, elle ne contient que les éléments de la MiniLibX et les données utiles à notre tableau.
						</p>
						<pre><code>typedef struct s_data {
	// MiniLibX
	void	*mlx;
	void	*mlx_win;
	void	*img;
	char	*addr;
	int	bits_per_pixel;
	int	line_length;
	int	endian;
	int	win_height;
	int	win_width;

	// Tab
	int	**tab;
	int	tab_width;
	int	tab_height;
}	t_data;</pre></code>
						<p>
							Il est important de dissocier les dimensions de la fenêtre (<i>win_height</i> et <i>win_width</i> qui sont en pixels) des dimensions de notre tableau (<i>tab_height</i> et <i>tab_width</i> qui indiquent la hauteur et largeur de notre tableau en nombre de cellule).
						</p>

						<p>Voyons maintenant comment créer notre tableau deux dimensions.</p>

						<p>
							Par la suite, pour visualiser le contenu du tableau, nous allons mettre un mur toutes les deux cellules (un mur étant la valeur 1).
						</p>
						<pre><code>int init_tab(t_data *data)
{
	// Setting initial tab dimensions
	data->tab_height = 15;
	data->tab_width = 20;

	// Allocating tab
	data->tab = malloc(sizeof(int *) * data->tab_height);
	if (data->tab == NULL) // Checking malloc error
		return (1);

	for (int y = 0; y < data->tab_height; y++)
	{
		data->tab[y] = malloc(sizeof(int) * data->tab_width);
		if (data->tab[y] == NULL) // Checking malloc error
			return (1);

		// Putting values in tab
		for (int x = 0; x < tab_width; x++)
		{
			data->tab[y][x] = (y % 2 + x) % 2;
		}
	}
	return (0);
}</pre></code>

						<h4>Affichage de la carte</h4>
						<p>
							L'objectif est désormais d'afficher sur notre fenêtre le contenu du tableau tout juste créé.<br>
							Ici la difficulté est de passer du format de tableau (coordonnée de cellule) à une coordonnée en pixel de la fenêtre.
							La première chose à faire est de définir la taille (en pixel) que prendront nos cellules sur l'écran. Cette variable, ici nommée <i>cell_size</i>, est stockée dans notre structure <i>data</i>.
						</p>

						<pre><code>void	print_grid(t_data *data)
{
	for (int y = 0; y < tab_height; y++)
	{
		for (int x = 0; x < tab_width; x++)
		{
			// Calculating square coordinates
			t_vector2_d top_left = {
				x * data->cell_size, // x
				y * data->cell_size // y
			};
			t_vector2_d bottom_right = {
				top_left.x + data->cell_size,
				top_left.y + data->cell_size
			};

			// Drawing square
			if (data->tab[y][x] == 1) // If the cell is a wall
			{
				draw_rect_color(data, top_left, bottom_right, PINK);
			}
		}
	}
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<div class="col-3"><span class="image fit"><img src="images/cube3d/basic_grid.png" alt="" /></span></div>
									<center><sup><i>Tableau de 20 x 15</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>Voici le résultat obtenu lorsque l'on affiche le tableau précédemment généré. Le damier provient de la formule <i>(y % 2 + x) % 2</i> utilisé lors de la création du tableau. Je vous invite cependant à la modifier pour créer différents motifs.
								</p>
							</div>
						</div>

						<h4>Modification de la carte</h4>
						<p>
							Maintenant que nous avons la possibilité de visualiser notre tableau, nous pouvons essayer de le modifier pendant l'exécution du programme.<br>
							À la fin, nous pourrons placer des murs à l'aide du clique gauche, et les supprimer avec le clique droit de la souris.
						</p>

						<p>Cette fois-ci, le problème est de convertir la position de la souris sur la fenêtre (qui est en pixel) en coordonnées de cellules.</p>
						<p>Encore une fois, c'est <i>cell_size</i> qui va nous nous aider à résoudre ce problème.</p>

						<pre><code>void	set_grid_cell(t_data *data, int x, int y)
{
	// Converting pixel coordinates to tab coordinates
	t_vector2_d tab_pos = {
		x / data->cell_size, // x
		y / data->cell_size // y
	};

	// Checking out of range coordinates
	if (x < 0 || x >= data->tab_width || y < 0 || y >= data->tab_height)
		return;

	// Changing cell value according to mouse button
	if (data->mouse_button == LMB)
		data->tab[tab_pos.y][tab_pos.x] = 1;
	else if (data->mouse_button == RMB)
		data->tab[tab_pos.y][tab_pos.x] = 0;
}</code></pre>


						<div class="row">
							<div class="col-5">
								<p>
									Cette fonctionnalité nous sera très utile pour tester l'implémentation de notre premier lancer de rayons.<br>
									Il va consister à analyser la collision entre un mur et un segment (défini par un point d'origine et une direction).
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/set_grid.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration ajout / suppression de murs</i></sup></center>
								</span>
							</div>
						</div>

						<h4>Détection de collision</h4>

						<div class="row">
							<div class="col-5">
								<p>
									Pour aborder les choses simplement, commençons par créer un rayon du centre de la fenêtre à la position du curseur.<br>
									Rien de plus simple, à l'aide d'une fonction de tracer de segment (Bresenham dans l'exemple), on relie le centre de l'écran et la souris.
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/mouse_segment.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration tracé de segment</i></sup></center>
								</span>
							</div>
						</div>

						<p>
							L'idée ici est d'afficher l'endroit où le segment entre en collision avec un mur.</p>
						<p>
							Il existe de nombreux moyens de faire ceci. Le moyen le plus simple serait de vérifier pour chaque pixel sur lequel passe le segment, si celui-ci appartient à un mur.<br>
							Cependant, dès que le nombre de segment augmente, cette option devient extrêmement couteuse et devient rapidement inutilisable.
						</p>
						<p>
							Une méthode un peu plus élégante et adaptée à notre situation est l'analayseur différentiel numérique (plus connu sous son acronyme anglais : DDA).<br>
							Cet algorithme est utilisé pour faire varier des données depuis un point de départ, jusqu'à un point d'arrivé.
						</p>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/ray_collision.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration détection de collision</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Dans notre cas, la DDA permet de parcouris intelligemment les cases du tableau sur lesquelles passe notre rayon.<br>
									C'est de cette manière qu'il est possible de détecter quand une collision se produit entre un mur et un rayon.
								</p>
							</div>
						</div>

						<p>
							La vidéo précédente montre une implémentation basique de la DDA. A partir d'un point de départ (ici le centre de l'écran) le programme va prendre comme
							direction la position du curseur. Il va alors parcourir toutes les cellules dans cette direction jusqu'à rencontrer une collision.
						</p>
						<p>
							Bien évidemment, si la carte n'est pas entourée de murs, le programme continuera ses calculs à l'infini (causant un magnifique plantage de l'application).<br>
							Il faut donc bien attention à deux choses :
						</p>
						<ul>
							<li>Imposer une distance maximale de recherche de collision</li>
							<li>Vérifier que la coordonnée (en pixel) soit dans la portée de notre tableau (sous peine de créer une erreur de segmentation)</li>
						</ul>
						<p>
							Dans le cas où la DDA ne rencontre pas de collision, il faut définir quelle valeur celle-ci retournera.<br>
							Étant donné que les coordonnées de notre tableau sont exclusivement positives, la valeur retournée par une "non-collision" sera un vecteur de (-1, -1).
						</p>

						<h4>Création d'un cône de vision</h4>
						<p>
							Ce champ visuel sera constitué d'une multitude de rayons. On souhaite pouvoir modifier le nombre de rayons, la largeur, mais également la distance maximale de ce champ de vision.<br>
							L'astuce est d'utiliser un segment afin de savoir où seront placés nos rayons. La position et la dimension de ce segment seront définies en fonction de la distance de vision et de la largeur du champ de vision.
						</p>

						<p>Nous allons commencer par limiter la longueur du segment [centre de l'écran | curseur] par une distance maximale.<br></p>

						<pre><code>void	create_rays(t_data *data, int length)
{
	t_vector2_d origin = {
		data->win_width / 2,
		data->win_height / 2
	};

	// Getting the angle (in radian) of mouse position according to the origin
	double angle = get_angle(origin, data->mouse_pos);

	t_vector2_d	direction = create_vector_d_from_origin(origin, -angle, length);
	draw_circle_color(data, direction, GREEN);
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/ray_max_length.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration détection de collision</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									L'utilisation d'une distance maximum de vision permet de rendre les capacités visuelles du joueur adaptable à différents scénarios.<br>
									Elle permet également de ne pas tirer un rayon à l'infini si aucun obstacle ne se trouve sur son chemin.
								</p>
							</div>
						</div>

						<p>
							La fonction <i>create_vector_d_from_origin</i> permet depuis une position de départ, de créer un vecteur dans une direction spécifique (indiquée par un angle en radian) pour une longueur donnée (en pixel).
						</p>

						<p>
							Nous voila avec le centre de la base du cône de vision. Pour trouver la longueur de la base du cône, le plus simple est de considérer que nous travaillons sur 2 triangles rectangles.
						</p>
						<b>SCHEMA<br></b>

						<p>
							Ici nous voulons à partir d'un angle, définir la largeur de notre champ de vision. Rien de plus facile, il suffit d'utiliser la formule (tout droit tiré de SOH-CAH-TOA) qui dit : <br>
							Le côté opposé d'un triangle rectangle est égal à la tangente de l'angle multiplié par son côté adjacent.<br>
							Attention cependant, dans notre cas, l'angle est divisé par deux car nous avons séparé notre cône en deux triangles rectangles.
						</p>

						<p>
							Il ne reste qu'à placer les deux points à la base de notre cône.<br>
							Le plus pratique est de réutiliser la fonction <i>create_vect_d_from_origin</i>, et depuis <i>view_dist_pos</i> créer un vecteur de la longueur du côté opposé avec pour angle,
						</p>

						<pre><code>void	create_rays(t_data *data)
{
	t_vector2_d origin = {data->win_width / 2, data->win_height / 2};

	// Getting the angle (in radian) of mouse position according to the origin
	double angle = get_angle(origin, data->mouse_pos);

	t_vector2_d view_dist_pos = create_vector_d_from_origin(origin, angle, data->view_dst);
	draw_circle_color(data, view_dist_pos, GREEN);

	int opposite_length = tan(degree_to_radian(data->fov / 2)) * data->view_dst;

	t_vector2_f opposite_vect[2] = {
		create_vector_f_from_origin(vector_d_to_f(view_dst_pos), angle + PI / 2, opposite_length),
		create_vector_f_from_origin(vector_d_to_f(view_dst_pos), angle - PI / 2, opposite_length)
	};

	draw_circle_color(data, opposite_vect[0], BLUE);
	draw_circle_color(data, opposite_vect[1], BLUE);
}</code></pre>


						<div class="row">
							<div class="col-5">
								<p>
									Il est important de noter que le degré du champ de vision ne pourra jamais atteindre (et donc ne peut pas dépasser) les 180°.<br>
									Plus la base du cone est longue plus le champs de vision sera large. A 180°, la longueur de la base du cône tendra donc vers l'infini (ce qui déplaira certainement à votre ordinateur).
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/cone_base.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration avec view_dst = 100 pixels et fov = 90°</i></sup></center>
								</span>
							</div>
						</div>

						<p>La dernière étape est de générer les coordonnées de N rayons entre les deux vecteurs de la base du cône.</p>
						<p>
							La méthode de l'interpolation linéaire permet de résoudre ce problème.<br>
							Son utilité est de pouvoir trouver les valeurs entre un minimum et un maximum.<br>
							Cette fonction prend trois paramètres : un minimum, un maximum et une valeur d'interpolation (entre 0 et 1).
						</p>
						<p>
							Si la valeur d'interpolation est égale à 0, la valeur minimum sera retournée, à l'inverse, si elle est égale à 1, la valeur maximum sera renvoyée. Enfin, si la valeur d'interpolation est égale à 0,5 la valeur retournée sera l'exact milieu entre le minimum et le maximum.
						</p>
						<p>
							Pour appliquer ce concept à des vecteurs il faut simplement faire une interpolation linéaire par composante du vecteur (une pour X et une autre pour Y).<br>
						</p>

						<p>Il suffit simpliment de calculer l'incrémentation de l'interpolation linéaire en fonction du nombre de rayons et le tour est joué.</p>

						<p>Le code suivant est la suite de la fonction <i>create_rays</i></p>
						<pre><code>double increment = 1.0f / (data->rays_nb - 1.0f);

for (int i = 0; i < data->rays_nb; i++)
{
	t_vector2_f vector = vector_f_lerp(opposite_vect[0], opposite_vect[1], increment * i);
	bresenham(data, origin, vector, YELLOW);
	data->rays[i].hit_point = vector;
}</code></pre>
						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/rays_interpolation.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration avec view_dst = 250 pixels, fov = 90° et 5 rayons</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Etant donnée que nous utiliserons énormément ces rayons, il est judicieux de créer une structure contenant plusieurs informations sur chaque rayon.<br>
									Comme par exemple le point de collision d'un rayon, le côté du mur qu'il a touché ou encore sa longueur.<br>
								</p>
								<p>
									L'usage de cette structure permet de garder en mémoire les données de différents rayons pour plus tard les réutiliser.<br>
									Cela nécessite simplement d'allouer un tableau de N rayons (stocké dans <i>data</i>) à l'initilisation de notre programme.
								</p>
							</div>
						</div>

						<p>
							Nous possédons maintenant plusieurs rayons mais tous passent au travers de la carte.<br>
							Fort heureusement nous possédons déja l'algorithme de DDA permettant de détecter une collision à partir d'une position de départ et de destination.
						</p>

						<p>
							Comme la DDA est uniquement utilisé avec les rayons, à la place de donner une position en argument il est plus pratique de donner une référence à un rayon.<br>
							La position <i>hit_point</i> du rayon sera utilisé comme destination et il sera en plus possible de modifier certaines données du rayon pendant l'exécution de la DDA.
						</p>

						<pre><code>void calculate_collisions(t_data *data)
{
	t_vector2_d origin = {data->win_width / 2, data->win_height / 2};

	for (int i = 0; i < data->rays_nb; i++)
	{
		t_vector2_f res = dda(data, data->rays[i]);

		if (res.x == -1 && res.y == -1) // Hit
			data->rays[i].hit_point = res; // Update ray hit point

		bresenham(data, origin, data->rays[i].hit_point, YELLOW);
	}
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/calculate_collisions.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration collisions avec 100 rayons</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Dans la vidéo suivante, la distance maximale de vision a été abaissée à 300 pixels.<br>
									On constate alors les rayons aux bords du cône de vision traversent parfois les murs.
								</p>
								<p>
									Ce phénomène provient du fait que la DDA arrete de détecter les collisions à partir de la distance maximale de vision.
									Cependant, la manière dont nous avons généré nos rayons fait que leur distance (depuis l'origine) est supérieure à cette distance maximale.
								</p>
							</div>
						</div>

						<p>
							Pour régler cette imprécision nous modifier la vecteur que reçois le rayon (dans la fonction <i>create_rays</i>) par :
						</p>
						<pre><code>data->rays[i].hit_point = create_vector_f_from_origin(
	origin,
	get_angle_f(origin, vector),
	data->view_dst
);</code></pre>
						<p>Le cône de vision possède désormais des bords arrondis rendant le résutat juste et précis.</p>
						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/bug_collision.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration cône de vision imprécis sur les bords</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/bug_collision_fixed.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration cône de vision avec des bords arrondis</i></sup></center>
								</span>
							</div>1
						</div>
						<hr>

						<h2>Conclusion</h2>
						<hr>

						<h2 id="sources">Sources</h2>
						<h2>Téléchargement</h2>
						<!-- petite liste de 2 colonnes avec les icone de github et itch-->
						<ul class="actions">
						<li><a href="https://github.com/B-Bischoff/Ecosystem" class="button icon brands fa-github">Code source</a></li>
						<li><a href="https://b-bischoff.itch.io/ecosystem" class="button icon brands fa-itch-io">Exécutable</a></li>
						</ul>
					</div>
				</div>

				<!-- Footer -->
				<footer id="footer">
					<div class="inner">
						<ul class="copyright">
							<li>Design adapté depuis une création : <a href="http://html5up.net">HTML5 UP</a></li>
						</ul>
					</div>
				</footer>

		</div>

	<!-- Scripts -->
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>

	</body>
</html>
