<!DOCTYPE HTML>
<!--
Phantom by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
	<title>Cube3d</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">
	<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
				<header id="header">
					<div class="inner">

						<!-- Logo -->
							<a href="index.html" class="logo">
								<span class="symbol"><img src="images/Square-grey.png" alt="" /></span><span class="title">Page principale</span>
							</a>

						<!-- Nav -->
							<nav>
								<ul>
									<li><a href="#menu">Menu</a></li>
								</ul>
							</nav>

					</div>
				</header>

			<!-- Menu -->
				<nav id="menu">
					<h2>Menu</h2>
					<ul>
						<li><a href="index.html">Projets</a></li>
						<li><a href="a-propos.html">A propos</a></li>
						<li><a href="contact.html">Contact</a></li>
					</ul>
				</nav>

			<!-- Main -->
				<div id="main">
					<div class="inner">
						<h1>Cube3d</h1>
						<span class="image main"><img src="images/cube3d/background-1.png" alt="" /></span>

						<h2>Contexte</h2>
						<hr>

						<h2>Réalisation</h2>

						<h3>Définition de raycasting</h3>
						<p>
							Notamment connu pour les célebres Doom et Wolfenstein 3D (dans les annees 1990), le raycasting 2D est une technique de calcul d'images permettant de représenter en 3D un univers en 2D.
						</p>

						<h3>Difference entre raycasting et raytracing</h3>
						<p>
							<b>A COMPLETER</b>
						</p>

						<h3>Librairie graphique</h3>
						<p>
							Le sujet impose l'utilisation de la librairie graphique : MiniLibX.<br>
							Cette librairie offre la possibilité de créer une fenetre, gérer des evenements ou encore dessiner sur des images.<br>
						</p>

						<b>EXEMPLE MLX ?</b><br><br>

						<h3>Fondamentaux</h3>
						<p>
							Comme dit précédemment, le raycasting se base sur un univers en deux dimensions (vu du dessus).<br>
							Voyons comment représenter informatiquement une carte contenant (pour commencer) des espaces vides et des murs.
						</p>

						<p>
							Le moyen le plus simple est d'utiliser un tableau a deux dimensions. Chacune de ses cellules aura une valeur que nous pourrons utiliser pour afficher notre monde (par exemple 1 pour un mur ou 0 pour un espace vide).
							Un désavantage de ce choix est que nous sommes contraint d'avoir un résultat ou toutes les surfaces seront quadrillées.
						</p>

						<p>
							Pour faciliter l'acces a nos données, nous utiliserons une structure nommée <i>data</i>. Pour l'instant, elle ne contient que les éléments de la MiniLibX et les données utiles a notre tableau. 
						</p>
<pre><code>typedef struct s_data {
	// MiniLibX
	void	*mlx;
	void	*mlx_win;
	void	*img;
	char	*addr;
	int	bits_per_pixel;
	int	line_length;
	int	endian;
	int	win_height;
	int	win_width;

	// Tab
	int	**tab;
	int	tab_width;
	int	tab_height;
}	t_data;</pre></code>
						<p>
							Il est important de dissocier les dimensions de la fenetre (<i>win_height</i> et <i>win_width</i> qui sont en pixels) des dimensions de notre tableau (<i>tab_height</i> et <i>tab_width</i> qui indiquent la hauteur et largeur de notre tableau en nombre de cellule).
						</p>

						<p>Voyons maintenant comment créer notre tableau deux dimensions.</p>

						<p>
							Pour par la suite visualiser le contenu du tableau, nous allons mettre un mur toutes les deux cellules (un mur étant la valeur 1).
						</p>
<pre><code>int init_tab(t_data *data)
{
	// Setting initial tab dimensions
	data->tab_height = 15;
	data->tab_width = 20;

	// Allocating tab
	data->tab = malloc(sizeof(int *) * data->tab_height);
	if (data->tab == NULL) // Checking malloc error
		return (1);

	for (int y = 0; y < data->tab_height; y++)
	{
		data->tab[y] = malloc(sizeof(int) * data->tab_width);
		if (data->tab[y] == NULL) // Checking malloc error
			return (1);

		// Putting values in tab
		for (int x = 0; x < tab_width; x++)
		{
			data->tab[y][x] = (y % 2 + x) % 2;
		}
	}
	return (0);
}</pre></code>

						<p>
							L'objectif est désormais d'afficher sur notre fenetre le contenu du tableau tout juste créé.<br>
							Ici la difficulté est de passer du format de tableau (coordonnée de cellule) a une coordonnée en pixel de la fenetre.
							La premiere chose a faire est de definir la taille (en pixel) que prendront nos cellules sur l'écran. Cette variable, ici nommée <i>cell_size</i>, est stockéé dans notre structure <i>data</i>.
						</p>

						<pre><code>void	print_grid(t_data *data)
{
	for (int y = 0; y < tab_height; y++)
	{
		for (int x = 0; x < tab_width; x++)
		{
			// Calculating square coordinates
			t_vector2_d top_left = {
				x * data->cell_size, // x
				y * data->cell_size // y
			};
			t_vector2_d bottom_right = {
				top_left.x + data->cell_size,
				top_left.y + data->cell_size
			};

			// Drawing square
			if (data->tab[y][x] == 1) // If the cell is a wall
			{
				draw_rect_color(data, top_left, bottom_right, PINK);
			}
		}
	}
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<div class="col-3"><span class="image fit"><img src="images/cube3d/basic_grid.png" alt="" /></span></div>
									<center><sup><i>Tableau de 20 x 15</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>Voici le résultat obtenu lorsque l'on affiche le tableau précédemment générée. Le damier provient de la formule <i>(y % 2 + x) % 2</i> utilisé lors de la création du tableau. Je vous invite cependant a la modifier pour créer différents motifs. 
								</p>
							</div>
						</div>

						<p>
							Maintenant que nous avons la possibilité de visualiser notre tableau, nous pouvons essayer de le modifier pendant l'éxécution du programme.<br>
							A la fin nous pourrons placer des murs a l'aide du clique gauche et les supprimer avec le clique droit de la souris.
						</p>

						<p>Cette fois-ci, le problème est de convertir la position de la souris sur la fenetre (qui est en pixel) en coordonées de cellules.</p>
						<p>Encore une fois, c'est <i>cell_size</i> qui va nous nous aider a résoudre ce probleme.</p>

						<pre><code>void	set_grid_cell(t_data *data, int x, int y)
{
	// Converting pixel coordinates to tab coordinates
	t_vector2_d tab_pos = {
		x / data->cell_size, // x
		y / data->cell_size // y
	};

	// Checking out of range coordinates
	if (x < 0 || x >= data->tab_width || y < 0 || y >= data->tab_height)
		return;
	
	// Changing cell value according to mouse button
	if (data->mouse_button == LMB)
		data->tab[tab_pos.y][tab_pos.x] = 1;
	else if (data->mouse_button == RMB)
		data->tab[tab_pos.y][tab_pos.x] = 0;
}</code></pre>

						<p>
							<b>VIDEO + EXPLIQUER POURQUOI CETTE FEATURE EST UTILE -> INTRO RAYON SUR MOUSE POS</b>
						</p>

						<hr>

						<h2>Conclusion</h2>
						<hr>

						<h2 id="sources">Sources</h2>
						<h2>Téléchargement</h2>
						<!-- petite liste de 2 colonnes avec les icone de github et itch-->
						<ul class="actions">
						<li><a href="https://github.com/B-Bischoff/Ecosystem" class="button icon brands fa-github">Code source</a></li>
						<li><a href="https://b-bischoff.itch.io/ecosystem" class="button icon brands fa-itch-io">Exécutable</a></li>
					</ul>
					</div>
				</div>

				<!-- Footer -->
				<footer id="footer">
					<div class="inner">
						<ul class="copyright">
							<li>Design adapté depuis une création : <a href="http://html5up.net">HTML5 UP</a></li>
						</ul>
					</div>
				</footer>

		</div>

	<!-- Scripts -->
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>

	</body>
</html>
