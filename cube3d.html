<!DOCTYPE HTML>
<!--
Phantom by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
	<title>Cube3d</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>

	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-CP7YYY7WEF"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'G-CP7YYY7WEF');
	</script>
</head>
<body class="is-preload">
	<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
				<header id="header">
					<div class="inner">

						<!-- Logo -->
							<a href="index.html" class="logo">
								<span class="symbol"><img src="images/Square-grey.png" alt="" /></span><span class="title">Page principale</span>
							</a>

						<!-- Nav -->
							<nav>
								<ul>
									<li><a href="#menu">Menu</a></li>
								</ul>
							</nav>

					</div>
				</header>

			<!-- Menu -->
				<nav id="menu">
					<h2>Menu</h2>
					<ul>
						<li><a href="index.html">Projets</a></li>
						<li><a href="a-propos.html">A propos</a></li>
						<li><a href="contact.html">Contact</a></li>
					</ul>
				</nav>

			<!-- Main -->
				<div id="main">
					<div class="inner">
						<h1>Cube3d</h1>
						<span class="image main"><img src="images/cube3d/background-1.png" alt="" /></span>

						<h2>Contexte</h2>
						<b>Sujet 42<br>Objectifs</b>
						<hr>

						<h2>Réalisation</h2>



						<h3>Librairie graphique</h3>
						<p>
							Le sujet impose l'utilisation de la librairie graphique : MiniLibX.<br>
							<b>PRECISER OS<br></b>
							Cette librairie offre la possibilité de créer une fenêtre, gérer différents types d'évènements ou encore dessiner sur des images.<br>
						</p>

						<h4>Création d'une fenêtre</h4>
						<p>
							Voici la manière la plus simple de créer une fenêtre à partir de la MiniLibX.<br>
							La fonction <i>mlx_init</i> renvoie un pointeur qui indique où se trouve l'instance de la mlx dans la mémoire. Le rôle de cette instance, est d'établir une connexion entre notre programme et l'environnement graphique de l'ordinateur.<br>
							La fonction <i>mlx_new_window</i> permet de définir la taille de la fenêtre ainsi que le titre de celle-ci.
						</p>
						<pre><code>int main(void)
{
	void *mlx;
	void *mlx_win;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "A simple window");
	mlx_loop(mlx);
}</pre></code>

						<p>
							C'est <i>mlx_loop</i> qui va s'occuper d'actualiser et d'afficher la fenêtre sur notre écran.<br>
							Nous allons dès à présent rendre cette fenêtre un peu plus intéressante en dessinant dessus.
						</p>

						<h4>Utilisation des images</h4>
						<p>
							Il existe la fonction <i>mlx_pixel_put</i> qui permet de placer des pixels sur notre fenêtre, cependant cette fonction extrêmement lente car elle place le pixel et actualise directement l'affichage.<br>
 							Par conséquent, j’ai opté pour un moyen plus optimisé, celui de stocker tous les pixels que l'on souhaite placer (à l'aide d'un buffer), et seulement lorsque tous les pixels sont stockés, la fenêtre met à jour son contenu.
						</p>
						<p>
							Le moyen de stocker les pixels est d'utiliser une image.<br>
							Cela implique de déclarer quelques variables supplémentaires comme :<br>
							<ul>
								<li>Une référence a l'instance de l'image</li>
								<li>L'adresse mémoire de l'image</li>
								<li>Le nombre de bits que chaque pixel occupe</li>
								<li>La taille en mémoire qu'occupe une ligne de l'image</li>
								<li>Une indication de quel boutiste (endian en anglais) utiliser</li>
							</ul>
						</p>

						<pre><code>typedef struct s_data {
	void *img;
	char *addr;
	int bits_per_pixel;
	int line_length;
	int endian;
} t_data;

int main(void)
{
	void *mlx;
	t_data img;

	mlx = mlx_init();
	img.img = mlx_new_image(mlx, 1920, 1080);
	img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);
}</code></pre>
						<p>
							Notre image (ici de dimension 1920 par 1080 pixels) est créée grâçe à la fonction <i>mlx_new_image</i><br>
							Les informations supplémentaires décrites précédemment sont assignées par la fonction <i>mlx_get_data_addr</i>.
						</p>

						<h4>Écriture sur une image</h4>
						<p>
							Le dernier élément manquant est un moyen de placer des pixels sur notre image.<br>
							La fonction suivante permet, à partir d'une coordonnée (x et y), d'écrire une certaine valeur (représentant une couleur) à l'endroit correspondant dans la mémoire de l'image.
						</p>
						<pre><code>void my_mlx_pixel_put(t_data *data, int x, int y, int color)
{
	char *dst;

	ddt = data->addr + (y * data->line_length + x * (data->bits_per_pixel / 8));
	*(unsigned int*)dst = color;
}</code></pre>
						<p>
							Les informations de l'image sont ici extrêmement utiles, elles nous permettent de trouver le décalage entre la position de chaque pixel et son emplacement dans la mémoire.<br>
						</p>
						<p>
							Il peut également être utile de vérifier la cohérence des coordonnées en début de fonction. Il se peut autrement que le programme aille chercher des données dans un espacement mémoire ne lui appartenant pas, causant ainsi l'arrêt du programme.
						</p>

						<h4>Affichage de l'image</h4>
						<p>
							Le moment tant attendu arrive, celui où nous allons voir des couleurs sur notre fenêtre !
							A l'aide des notions expliquées jusqu'ici (initialisation d'une fenêtre et d'une image ainsi que la structure <i>data</i>) nous allons appeler <i>my_mlx_pixel_put</i> et afficher le contenu de l'image sur notre fenêtre.
						</p>

						<pre><code>int main(void)
{
	void *mlx;
	void *mlx_win;
	t_data img;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "A simple window");
	img.img = mlx_new_image(mlx, 1920, 1080);
	img.addr = mlx_get_data_addr(img.img, &img.bits_per_pixel, &img.line_length, &img.endian);
	my_mlx_pixel_put(&img, 100, 100, 0x00FF0000);
	mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
	mlx_loop(mlx);
}</code></pre>

						<p>
							Ce petit code a pour effet de placer un pixel rouge (<b>LIEN MLX COLORS</b>) à la coordonnée (en pixels) 100, 100 de notre fenêtre.<br>
							C'est ensuite <i>mlx_put_image_to_window</i> qui va mettre a jour la fenêtre en affichant le contenu de notre image.
						</p>

						<h4>Boucles</h4>
						<p>
							Pour créer un jeu vidéo avec lequel il est possible d'interagir, il est nécessaire d'implémenter ce qu'on appel une "game loop".<br>
							<b>ILLUSTRATION GAME LOOP<br></b>
							Une game loop tourne en continue pendant l'éxécution du jeu. À chaque tour de boucle, le programme lit les entrées de l'utilisateur, met à jour le contenu du jeu puis actualise l'affichage.
						</p>
						<p>Voyons comment implémenter cette boucle a l'aide de la MiniLibX.</p>

						<pre><code>int render_next_frame(void *program_struct);

int main(void)
{
	void *mlx;
	t_struct program_struct;

	mlx = mlx_init();
	mlx_loop_hook(mlx, render_next_frame, &program_struct);
	mlx_loop(mlx);
}</code></pre>
						<p>À chaque frame, la fonction <i>render_next_frame</i> sera appelée avec pour paramètre <i>program_struct</i>.</p>

						<h4>Entrées utilisateur</h4>
						<p>Un jeu vidéo ne serait pas très intéressant sans possibilités d'interaction.</p>
						<p>
							La MiniLibX fournit la possibilité d'intercepter différents type d'évènements.<br>
							Ces évènements (par exemple liés à la souris ou au clavier) ne font qu'appeler une fonction quand ils se déclenchent.<br>
							Plus concrètement, il faut au début du programme, indiquer à la MiniLibX quelles sont les évenèments à écouter, et quelles fonctions vont-ils appeller en conséquence.
						</p>
						<p>
							Les évènements sont représentés par des nombres, voici une liste (minime) des évènements qui nous seront utiles :
							<ul>
								<li>02 : Touche du clavier pressée</li>
								<li>03 : Touche du clavier relâchée</li>
								<li>04 : Clique de souris pressé</li>
								<li>05 : Clique de souris relâché</li>
								<li>06 : Mouvement de la souris</li>
								<li>17 : Appui sur la croix rouge de la fenêtre</li>
							</ul>
						</p>

						<pre><code>int key_press(int keycode, t_struct *program_struct)
{
	printf("Key pressed : %d\n", keycode);
	return (0);
}

int main(void)
{
	void *mlx;
	void *mlx_win;
	t_struct program_struct;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "A simple window");
	mlx_hook(mlx_win, 2, 0, key_press, &program_struct);
	mlx_loop(mlx);
}</code></pre>
						<p>
							Rappelons que les actions effectuées en fonction des entrées utilisateur (par exemple déplacer le personnage du joueur) se font dans la game loop précédemment implémentée.<br>
							Les évènements ne vont donc pas effectuer d'actions sur les données de notre jeu (personnage, carte, interface ou autre), mais uniquement mettre à jour les informations liées a nos contrôles (état des touches du clavier, position du curseur, état des cliques de la souris).
						</p>
						<p>
							Cela implique pour notre programme d'avoir un moyen de stocker les données de nos périphériques.<br>
							Pour le clavier, il est possible de créer un tableau de booléens (du nombre de touches du clavier) et dès qu'une touche est pressée, la case du tableau correspondant à la touche est passée à vrai.<br>
							Voici le code permettant de gérer un tableau (d'une taile de 200 booléens) à l'aide des hooks 02 et 03.
						</p>

						<pre><code>int	key_press(int keycode, t_struct *prg_struct)
{
	if (keycode < 200)
		prg_struct->keyboard[keycode] = 1;

	return (0);
}

int	key_release(int keycode, t_struct *prg_struct)
{
	if (keycode < 200)
		prg_struct->keyboard[keycode] = 0;

	return (0);
}</code></pre>


						<p>Ainsi, dans notre game loop il ne reste qu'à vérifier si une touche (à une case précise du tableau) est appuyée pour effectuer une action.</p>

						<h3>Définition de raycasting</h3>
						<p>
							Notamment connu pour les célèbres Doom et Wolfenstein 3D (dans les années 1990), le raycasting 2D est une technique de calcul d'images permettant de représenter en 3D un univers en 2D.<br>
							Cette technique est extrêmement efficace car elle ne nécessite qu'un calcul par bande vertical de l'écran.<br>
							Le principe consiste à tirer une multitude de rayons (depuis la position du joueur), et d'afficher les murs et ennemies, en fonction de la distance d'impacte des rayons lancées.
						</p>

						<h3>Fondamentaux</h3>

						<h4>Représentation de la carte</h4>
						<p>
							Comme dit précédemment, le raycasting se base sur un univers en deux dimensions (vu du dessus).<br>
							Voyons, pour commencer, comment représenter informatiquement une carte contenant des espaces vides et des murs.
						</p>

						<p>
							Le moyen le plus simple est d'utiliser un tableau a deux dimensions. Chacune de ses cellules aura une valeur que nous pourrons utiliser pour afficher notre monde (par exemple 1 pour un mur ou 0 pour un espace vide).
							Un des désavantage de ce choix est que nous sommes contraint d'avoir un résultat où toutes les surfaces seront quadrillées.
						</p>

						<p>
							Pour faciliter l'accès à nos données, nous utiliserons une structure nommée <i>data</i>. Pour l'instant, elle ne contient que les éléments de la MiniLibX et les données utiles à notre tableau.
						</p>
						<pre><code>typedef struct s_data {
	// MiniLibX
	void	*mlx;
	void	*mlx_win;
	void	*img;
	char	*addr;
	int	bits_per_pixel;
	int	line_length;
	int	endian;
	int	win_height;
	int	win_width;

	// Tab
	int	**tab;
	int	tab_width;
	int	tab_height;
}	t_data;</pre></code>
						<p>
							Il est important de dissocier les dimensions de la fenêtre (<i>win_height</i> et <i>win_width</i> qui sont en pixels) des dimensions de notre tableau (<i>tab_height</i> et <i>tab_width</i> qui indiquent la hauteur et largeur de notre tableau en nombre de cellule).
						</p>

						<p>Voyons maintenant comment créer notre tableau deux dimensions.</p>

						<p>
							Par la suite, pour visualiser le contenu du tableau, nous allons mettre un mur toutes les deux cellules (un mur étant la valeur 1).
						</p>
						<pre><code>int init_tab(t_data *data)
{
	// Setting initial tab dimensions
	data->tab_height = 15;
	data->tab_width = 20;

	// Allocating tab
	data->tab = malloc(sizeof(int *) * data->tab_height);
	if (data->tab == NULL) // Checking malloc error
		return (1);

	for (int y = 0; y < data->tab_height; y++)
	{
		data->tab[y] = malloc(sizeof(int) * data->tab_width);
		if (data->tab[y] == NULL) // Checking malloc error
			return (1);

		// Putting values in tab
		for (int x = 0; x < tab_width; x++)
		{
			data->tab[y][x] = (y % 2 + x) % 2;
		}
	}
	return (0);
}</pre></code>

						<h4>Affichage de la carte</h4>
						<p>
							L'objectif est désormais d'afficher sur notre fenêtre le contenu du tableau tout juste créé.<br>
							Ici la difficulté est de passer du format de tableau (coordonnée de cellule) à une coordonnée en pixel de la fenêtre.
							La première chose à faire est de définir la taille (en pixel) que prendront nos cellules sur l'écran. Cette variable, ici nommée <i>cell_size</i>, est stockée dans notre structure <i>data</i>.<br>
							Dans tous les exemples se trouvant sur cette page, <i>cell_size</i> est égal à 40.
						</p>

						<pre><code>void	print_grid(t_data *data)
{
	for (int y = 0; y < tab_height; y++)
	{
		for (int x = 0; x < tab_width; x++)
		{
			// Calculating square coordinates
			t_vector2_d top_left = {
				x * data->cell_size, // x
				y * data->cell_size // y
			};
			t_vector2_d bottom_right = {
				top_left.x + data->cell_size,
				top_left.y + data->cell_size
			};

			// Drawing square
			if (data->tab[y][x] == 1) // If the cell is a wall
			{
				draw_rect_color(data, top_left, bottom_right, PINK);
			}
		}
	}
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<div class="col-3"><span class="image fit"><img src="images/cube3d/basic_grid.png" alt="" /></span></div>
									<center><sup><i>Tableau de 20 x 15</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>Voici le résultat obtenu lorsque l'on affiche le tableau précédemment généré. Le damier provient de la formule <i>(y % 2 + x) % 2</i> utilisé lors de la création du tableau. Je vous invite cependant à la modifier pour créer différents motifs.
								</p>
							</div>
						</div>

						<h4>Modification de la carte</h4>
						<p>
							Maintenant que nous avons la possibilité de visualiser notre tableau, nous pouvons essayer de le modifier pendant l'exécution du programme.<br>
							À la fin, nous pourrons placer des murs à l'aide du clique gauche, et les supprimer avec le clique droit de la souris.
						</p>

						<p>Cette fois-ci, le problème est de convertir la position de la souris sur la fenêtre (qui est en pixel) en coordonnées de cellules.</p>
						<p>Encore une fois, c'est <i>cell_size</i> qui va nous nous aider à résoudre ce problème.</p>

						<pre><code>void	set_grid_cell(t_data *data, int x, int y)
{
	// Converting pixel coordinates to tab coordinates
	t_vector2_d tab_pos = {
		x / data->cell_size, // x
		y / data->cell_size // y
	};

	// Checking out of range coordinates
	if (x < 0 || x >= data->tab_width || y < 0 || y >= data->tab_height)
		return;

	// Changing cell value according to mouse button
	if (data->mouse_button == LMB)
		data->tab[tab_pos.y][tab_pos.x] = 1;
	else if (data->mouse_button == RMB)
		data->tab[tab_pos.y][tab_pos.x] = 0;
}</code></pre>


						<div class="row">
							<div class="col-5">
								<p>
									Cette fonctionnalité nous sera très utile pour tester l'implémentation de notre premier lancer de rayons.<br>
									Il va consister à analyser la collision entre un mur et un segment (défini par un point d'origine et une direction).
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/set_grid.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration ajout / suppression de murs</i></sup></center>
								</span>
							</div>
						</div>

						<h4>Détection de collision</h4>

						<div class="row">
							<div class="col-5">
								<p>
									Pour aborder les choses simplement, commençons par créer un rayon du centre de la fenêtre à la position du curseur.<br>
									Rien de plus simple, à l'aide d'une fonction de tracer de segment (Bresenham dans l'exemple), on relie le centre de l'écran et la souris.
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/mouse_segment.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration tracé de segment</i></sup></center>
								</span>
							</div>
						</div>

						<p>
							L'idée ici est d'afficher l'endroit où le segment entre en collision avec un mur.</p>
						<p>
							Il existe de nombreux moyens de faire ceci. Le moyen le plus simple serait de vérifier pour chaque pixel sur lequel passe le segment, si celui-ci appartient à un mur.<br>
							Cependant, dès que le nombre de segment augmente, cette option devient extrêmement couteuse et devient rapidement inutilisable.
						</p>
						<p>
							Une méthode un peu plus élégante et adaptée à notre situation est l'analayseur différentiel numérique (plus connu sous son acronyme anglais : DDA).<br>
							Cet algorithme est utilisé pour faire varier des données depuis un point de départ, jusqu'à un point d'arrivé.
						</p>

						<h4>Explications détaillées de la DDA</h4>

						<p>
							L'objectif est de parcourir toutes les cellules séparant le point de départ et d'arrivée.<br>
							Grace à ces deux éléments, nous pouvons déterminer la direction à emprunter, la difficulté est de pouvoir passer d'une cellule
							à l'autre de manière optimisée (ne pas scruter deux fois le même endroit ou ne pas rater de cellules).
						</p>
						<p>
							Nous voulons également être le plus précis possible étant donné que la position du joueur sera définie par des nombres à virgules.
						</p>

						<p>
						 	Afin de nous déplacer vers le point d'arrivée, il faut alterner entre avancer (de 1 pixel à chaque fois)
							sur l'axe horizontal et vertical.
						</p>

						<p>
							Pour ne rater aucune cellule, il faut progresser sur l'axe le moins avancé.<br>
							Mesurer l'avancement d'un axe se fait en utilisant les propriétés du triangle rectangle.<br>
							Il est possible de calculer la longueur de l'hypténuse pour un avancement de 1 (pour l'axe horizontal ET vertical) en utilisant la pente de la droite.<br>
							La dernière étape est d'avancer sur l'axe qui possède la plus petite longueur d'hypoténuse, jusqu'à rencontrer une collision.
						</p>

						<p>
							Comme indiqué précédemment, la position de notre joueur ne sera pas forcément des nombres entiers. Il faut donc initialement calculer l'écart entre
							la position de départ et la coordonée entière la plus proche.
						</p>

						<p>
							Les deux morceaux de code qui suivront proviennent de la page <a href="https://lodev.org/cgtutor/raycasting.html"><i>Lode's Computer Graphics Tutorial</i></a> ainsi que du tutoriel de <a href="https://www.youtube.com/watch?v=NbSee-XM7WA"><i>javidx9</i></a>
							sur le raycasting que vous pouvez consulter pour avoir les détails des calculs.
						</p>

						<p>La première étape de la DDA consiste à initialiser toutes les données dont nous avons besoin.</p>

						<b>GIF THEORIE DDA</b>

						<pre><code>t_vector2_f dda(t_data *data, t_vector2_f dest)
{
	t_vector2_d origin = {win_width / 2, win_height / 2};

	t_vector2_d map = vector_f_to_d(origin); // Position used to check tab value
	t_vector2_f dir = {dest.x - origin.x, dest.y - origin.y};

	t_vector2_f side_dist; // Origin point offset to the nearest int positon
	t_vector2_f delta_dist; // Length of the hyptenuse

	delta_dist.x = (dir.x == 0) ? 1e30 : ft_abs(1.0f / dir.x); // 1e30 is a large value
	delta_dist.y = (dir.y == 0) ? 1e30 : ft_abs(1.0f / dir.y);

	t_vector2_d step;
	if (dir.x < 0)
	{
		step.x = -1; // Calculating X step (depending on the direction)
		side_dist.x = (origin.x - map.x) * delta_dist.x; // Calculating X gap to the nearest integer coordinate
	}
	else
	{
		step.x = 1;
		side_dist.x = (map.x + 1.0f - origin.x) * delta_dist.x;
	}

	if (dir.y < 0)
	{
		step.y = -1; // Calculating Y step (depending on the direction)
		side_dist.y = (origin.y - map.y) * delta_dist.y; // Calculating Y gap to the nearest integer coordinate
	}
	else
	{
		step.y = 1;
		side_dist.y = (map.y + 1.0f - origin.y) * delta_dist.y;
	}

}</code></pre>

						<p>
							Maintenant que nous savons dans quelle direction nous diriger, il est temps de partir à la recherche d'une collision.<br>
							Voici une version extrêmement simple de la DDA.
						</p>
						<p><i>Le code suivant est la suite de la fonction DDA</i></p>

						<pre><code>while (1)
{
	if (side_dist.x < side_dist.y)
	{
		side_dist.x += delta_dist.x;
		map.x += step.x;
	}
	else
	{
		side_dist.y += delta_dist.y;
		map.y += step.y;
	}

	// Converting pixel coordinates to tab coordinates
	t_vector2_d cell = {
		map.x / data->cell_size,
		map.y / data->cell_size
	};

	if (data->tab[cell.y][cell.x] == 1) // Is a wall
	{
		return (vector_d_to_f(map));
	}
}
</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/ray_collision.mp4" type="video/webm">
									</video>
									<center><sup><i>Démonstration détection de collision</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									La vidéo suivante montre une démonstration de la DDA. A partir d'un point de départ (ici le centre de l'écran) le programme va prendre comme
									direction la position du curseur. Il va alors parcourir toutes les cellules dans cette direction jusqu'à rencontrer une collision, représentée par un cercle vert.
								</p>
							</div>
						</div>

						<p>
							Bien évidemment, si la carte n'est pas entourée de murs, le programme continuera ses calculs à l'infini (causant un magnifique plantage de l'application).<br>
							Il faut donc bien faire attention à deux choses :
						</p>
						<ul>
							<li>Imposer une distance maximale de recherche de collision</li>
							<li>Vérifier que la coordonnée (en pixel) soit dans la portée de notre tableau (sous peine de créer une erreur de segmentation)</li>
						</ul>
						<p>
							Dans le cas où la DDA ne rencontre pas de collision, il faut définir quelle valeur celle-ci retournera.<br>
							Étant donné que les coordonnées de notre tableau sont exclusivement positives, la valeur retournée par une "non-collision" sera un vecteur de (-1, -1).
						</p>

						<p>
							Voici donc une version améliorée de la DDA. La recherche de collision est désormais limitée par une distance maximale, et l'accès au tableau est sécurisé.<br>
							L'utilisation de l'instruction <i>continue</i> permet de détecter des collisions malgré le fait que le joueur soit hors de la carte.
						</p>

						<pre><code>// Using squared values is faster than using square root function
float ray_length = get_vector_d_length_squared(origin, map);

while (ray_length < data->view_dst * data->view_dst)
{
	if (side_dist.x < side_dist.y)
	{
		side_dist.x += delta_dist.x;
		map.x += step.x;
	}
	else
	{
		side_dist.y += delta_dist.y;
		map.y += step.y;
	}

	ray_length = get_vector_d_length_squared(origin, map);

	// Converting pixel coordinates to tab coordinates
	t_vector2_d cell = {
		map.x / data->cell_size,
		map.y / data->cell_size
	};

	if (cell.x < 0 || cell.x >= data->win_width)
		continue;
	if (cell.y < 0 || cell.y >= data->win_height)
		continue;

	if (data->tab[cell.y][cell.x] == 1) // Is a wall
	{
		return (vector_d_to_f(map));
	}
}</code></pre>

						<h4>Utilisation d'une structure "rayon"</h4>

						<p>Tout le concept du raycasting gravite autour de "rayons". Ils permettent à partir de notre monde 2D, d'afficher un résultat semblable à de la 3D.</p>
						<p>Le champs de vision du joueur ne sera ni plus ni moins qu'un ensemble de rayons, ayant pour but de représenter à l'écran le monde environnant à partir des informations qu'ils contiennent.</p>

						<p>
							La dernière vidéo illustre une version extrêmement basique d'un rayon.<br>
							Cependant, comme il est nécessaire de stocker plusieurs informations pour un seul rayon, ceci seront représentées par une structure.
						</p>

						<p>Pour le moment, les informations dont nous aurons besoin sont les suivantes :</p>

						<div class="row">
							<div class="col-4">
								<pre><code>typedef struct t_ray {
	t_vector2_f hit_point;
	t_vector2_d cell;
	double length;
	int side_hit;
	double angle;
} t_ray;</code></pre>
							</div>
							<div class="col-7">
								<ul>
									<li>
										<i>hit_point</i> : Cette valeur va premièrement indiquer dans quelle direction chercher une collision (de la même manière que la souris dans l'exemple précédent).
										Sa valeur sera alors mise à jour si une collision a été trouvée.
									</li>
									<li>
										<i>cell</i> : La position de la cellule sur laquelle à eu lieu l'impact est conservée dans le vecteur <i>cell</i> en coordonée de cellules.
									</li>
									<li>
										<i>length</i> : Pour par la suite afficher une portion de mur dans la phase de rendu, il est important de connaître la longueur du rayon (entre le joueur et le point d'impact du rayon).
									</li>
									<li>
										<i>side_hit</i> : Le côté du mur a été touché, cette valeur allant de 0 à 3 va nous permettre d'afficher une couleur différente pour chaque orientation du mur.
									</li>
									<li>
										<i>angle</i> : Le degré en radian du rayon.
									</li>
								</ul>
							</div>
						</div>


						<p>
							L'usage de cette structure permet de garder en mémoire ces données pour plus tard les réutiliser.
Cela nécessite d'allouer un tableau de N rayons (stocké dans data) à l'initilisation de notre programme.
						</p>


						<p>
							Certaines valeurs (comme <i>side_hit</i> ou <i>cell</i>) peuvent dores et déjà être obtenues depuis la fonction DDA.<br>
							Pour mettre à jour les données d'un rayon au sein même de cette fonction, il faut modifier ses paramètres pour lui passer une référence à un rayon.
						</p>

						<p>Voici à quoi ressemble désormais le prototype de la fonction <i>DDA</i></p>
						<pre><code>t_vector2_f dda(t_data *data, t_ray *ray)</code></pre>
						<p>
							Il ne reste qu'à assigner <i>ray->cell</i> et <i>ray->side_hit</i> (ce dernier pouvant être determiné grâce à <i>side_dist</i>).
							Mais surtout ! Remplacer <i>dest</i> par <i>ray->hit_point</i> qui est calculé dans la partie suivante.
						</p>

						<h4>Création d'un cône de vision</h4>
						<p>
							Ce champ visuel sera constitué d'une multitude de rayons. On souhaite pouvoir modifier le nombre de rayons, la largeur, mais également la distance maximale de ce champ de vision.<br>
							L'astuce est d'utiliser un segment afin de savoir où seront placés nos rayons. La position et la dimension de ce segment seront définies par la distance de vision ainsi que la largeur du champ de vision.
						</p>

						<p>Nous allons commencer par limiter la longueur du segment [centre de l'écran | curseur] par une distance maximale, <i>view_dst</i> stockée dans dans notre structure <i>data</i></p>

						<pre><code>void	create_rays(t_data *data)
{
	t_vector2_d origin = {
		data->win_width / 2,
		data->win_height / 2
	};

	// Getting the angle (in radian) of mouse position according to the origin
	double angle = get_angle(origin, data->mouse_pos);

	t_vector2_d view_dst_pos = create_vector_d_from_origin(origin, angle, data->view_dst);
	draw_circle_color(data, direction, GREEN);
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/ray_max_length.mp4" type="video/webm">
									</video>
									<center><sup><i>Affichage de view_dst_pos</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									L'utilisation d'une distance maximum de vision permet de rendre les capacités visuelles du joueur adaptable à différents scénarios.<br>
									Elle permet également de ne pas tirer un rayon à l'infini si aucun obstacle ne se trouve sur son chemin.
								</p>
							</div>
						</div>

						<p>
							La fonction <i>create_vector_d_from_origin</i> permet depuis une position de départ, de créer un vecteur dans une direction spécifique (indiquée par un angle en radian) pour une longueur donnée (en pixel).
						</p>

						<div class="row">
							<div class="col-7">
								<p>
									Nous voila avec le centre de la base du cône de vision. Pour trouver la longueur de la base du cône, le plus simple est de considérer que nous travaillons sur 2 triangles rectangles.
								</p>
								<p>
									Ici nous voulons à partir d'un angle, définir la largeur de notre champ de vision. Rien de plus facile, il suffit d'utiliser la formule (tout droit tiré de SOH-CAH-TOA) qui dit : <br>
									Le côté opposé d'un triangle rectangle est égal à la tangente de l'angle multiplié par son côté adjacent.<br>
									Attention cependant, dans notre cas, l'angle est divisé par deux car nous avons séparé notre cône en deux triangles rectangles.
								</p>
							</div>
							<div class="col-4">
								<span class="image fit">
									<span class="image fit"><img src="images/cube3d/schema-cone.png" alt="" /></span>
								</span>
							</div>
						</div>

						<p>
							Il ne reste qu'à placer les deux points à la base de notre cône.<br>
							Le plus pratique est de réutiliser la fonction <i>create_vect_d_from_origin</i>, et depuis <i>view_dst_pos</i> créer un vecteur de la longueur du côté opposé.<br>
							L'angle du premier point sera la direction du joueur +90° et -90° pour le second.
						</p>

						<pre><code>void	create_rays(t_data *data)
{
	t_vector2_d origin = {data->win_width / 2, data->win_height / 2};

	// Getting the angle (in radian) of mouse position according to the origin
	double angle = get_angle(origin, data->mouse_pos);

	t_vector2_d view_dst_pos = create_vector_d_from_origin(origin, angle, data->view_dst);
	draw_circle_color(data, view_dst_pos, GREEN);

	int opposite_length = tan(degree_to_radian(data->fov / 2)) * data->view_dst;

	t_vector2_f opposite_vect[2] = {
		create_vector_f_from_origin(vector_d_to_f(view_dst_pos), angle + PI / 2, opposite_length),
		create_vector_f_from_origin(vector_d_to_f(view_dst_pos), angle - PI / 2, opposite_length)
	};

	draw_circle_color(data, opposite_vect[0], BLUE);
	draw_circle_color(data, opposite_vect[1], RED);
}</code></pre>


						<div class="row">
							<div class="col-5">
								<p>
									Il est important de noter que le degré du champ de vision ne pourra jamais atteindre (et donc ne peut pas dépasser) les 180°.<br>
									Plus la base du cône est longue plus le champs de vision sera large. A 180°, la longueur de la base du cône tendra donc vers l'infini (ce qui déplaira certainement à votre ordinateur).
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/cone_base.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration avec view_dst = 100 pixels et fov = 90°</i></sup></center>
								</span>
							</div>
						</div>

						<p>La dernière étape est de générer les coordonnées de N rayons entre les deux vecteurs de la base du cône.</p>
						<p>
							La méthode de l'interpolation linéaire permet de résoudre ce problème.<br>
							Son utilité est de pouvoir trouver les valeurs entre un minimum et un maximum.<br>
							Cette fonction prend trois paramètres : un minimum, un maximum et une valeur d'interpolation (entre 0 et 1).
						</p>
						<p>
							Si la valeur d'interpolation est égale à 0, la valeur minimum sera retournée, à l'inverse, si elle est égale à 1, la valeur maximum sera renvoyée. Enfin, si la valeur d'interpolation est égale à 0,5 la valeur retournée sera l'exact milieu entre le minimum et le maximum.
						</p>
						<p>
							Pour appliquer ce concept à des vecteurs il faut simplement faire une interpolation linéaire par composante du vecteur (une pour X et une autre pour Y).<br>
						</p>

						<p>Il suffit simplement de calculer l'incrémentation de l'interpolation linéaire en fonction du nombre de rayons et le tour est joué.</p>

						<p>Le code suivant est la suite de la fonction <i>create_rays</i></p>
						<pre><code>double increment = 1.0f / (data->rays_nb - 1.0f);

for (int i = 0; i < data->rays_nb; i++)
{
	t_vector2_f vector = vector_f_lerp(opposite_vect[0], opposite_vect[1], increment * i);
	bresenham(data, origin, vector, YELLOW);
	data->rays[i].angle = get_angle_f(origin, vector); // Set ray angle
	data->rays[i].hit_point = vector; // Set ray direction
}</code></pre>
						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/rays_interpolation.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration avec view_dst = 250 pixels, fov = 90° et 5 rayons</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Nous possédons maintenant plusieurs rayons simulant notre champs de vision. Cependant, si vous essayez de placer des murs devant eux, tous passerons au travers.<br>
									Fort heureusement nous possédons déja l'algorithme de DDA permettant de détecter une collision à partir d'une position de départ et d'un rayon.
								</p>
							</div>
						</div>

						<p>
							Nous aurons plus tard besoin de connaitre la longueur des rayons ayant touché un mur, il faut donc un moyen d'indiquer quand les rayons n'ont pas heurté de mur.<br>
							De la même manière que pour la DDA, nous symboliserons une "non-collision" par une longueur de -1.
						</p>

						<pre><code>void calculate_collisions(t_data *data)
{
	t_vector2_d origin = {data->win_width / 2, data->win_height / 2};

	for (int i = 0; i < data->rays_nb; i++)
	{
		t_vector2_f res = dda(data, &data->rays[i]); // Passing ray reference

		if (res.x != -1 && res.y != -1) // Hit
		{
			data->rays[i].hit_point = res; // Update ray hit point
			data->rays[i].length = get_vector_f_length(origin, res);
		}
		else
		{
			data->rays[i].length = -1;
		}

		bresenham(data, origin, data->rays[i].hit_point, YELLOW);
	}
}</code></pre>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/calculate_collisions.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration collisions avec 100 rayons et distance max de 1000 pixels</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Voici le résultat obtenu une fois tous les rayons passés dans la DDA.<br>
									N'oubliez pas d'uniquement afficher le résultat à partir de cette fonction, ou bien de tracer les traits d'une couleur différentes que dans la fonction <i>create_rays</i>.
								</p>
							</div>
						</div>

						<p>
							Dans la vidéo un peu plus bas, la distance maximale de vision a été abaissée à 300 pixels.<br>
							On constate alors les rayons aux bords du cône de vision traversent parfois les murs.
						</p>
						<p>
							Ce phénomène provient du fait que la DDA cesse de détecter les collisions à partir de la distance maximale de vision.
							Cependant, la manière dont nous avons généré nos rayons fait que la distance des rayons aux extremités du cône, est supérieure à cette distance maximale.
						</p>

						<p>
							Pour régler cette imprécision visuelle, il faut normaliser le vecteur que reçois le rayon à la longeur maximale de vision.<br>
							Le cône de vision possède désormais des bords arrondis rendant le résutat juste et précis.
						</p>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/bug_collision.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration cône de vision imprécis sur les bords</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/bug_collision_fixed.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration cône de vision avec des bords arrondis</i></sup></center>
								</span>
							</div>
						</div>

						<i>partie de code provenant de la fonction "calculate_collisions"</i>
						<pre><code>if (res.x != -1 && res.y != -1) // Hit
{
	data->rays[i].hit_point = res; // Update ray hit point
	data->rays[i].length = get_vector_f_length(data->player.pos, res);
}
else
{
	data->rays[i].length = -1;
	data->rays[i].hit_point = create_vector_f_from_origin(origin, get_angle_f(origin, vector), data->view_dst);
}</code></pre>

						<h4>Déplacements</h4>
						<p>Pour rendre notre programme un peu plus interactif essayons de controler notre joueur avec le clavier.</p>

						<p>
							Pour ordonner nos données, le joueur possèdera sa propre structure contenant ses informations.<br>
							Une variable player (de type <i>t_player</i> sera donc ajoutée à notre structure data).
						</p>

						<pre><code>typedef struct s_player {
	t_vector2_f	pos;
	t_vector2_d	view_dst_pos;
	t_vector2_f	dir;
}	t_player</code></pre>

<p></p>
						<p>
							La position du joueur est définie par un vecteur utilisant des nombres flottants. Ce n'est pas obligatoire mais cela permet de rajouter un peu de précision et de fluidité à nos déplacements.<br>
							Nous avons précédemment utilisé <i>view_dst_pos</i> pour générer nos rayons. Il fait sens de rattacher cette variable au joueur étant donnée que seul lui l'utilise et que nous en aurons besoin à différents endroits du programme.<br>
							Enfin, <i>dir</i> permet de stocker en radian, la direction vers laquelle regarde le joueur.
						</p>

						<p>
							Pour détecter et exécuter les entrées utilisateurs, nous allons comme indiqué par le concept de <i>gameloop</i>, créer une fonction en début <i>d'update</i> à cet effet.
						</p>

						<pre><code>int player_input(t_data *data)
{
	if (data->keyboard[KEY_A] == 1)
		rotate_left(data);
	if (data->keyboard[KEY_E] == 1)
		rotate_right(data);
	return (0);
}</code></pre>
						<p>
							Le format de cette fonction permet d'aisément rajouter des possibilités d'interaction à notre jeu. Pour l'instant il n'y a que la rotation mais plus tard nous ajouterons les déplacements du personnage.
						</p>

						<p>
							Pour effectuer la rotation de notre personnage nous utiliserons la variables <i>dir</i>. C'est d'ailleurs cette variable qui va nous permettre de calculer <i>view_dst_pos</i>.
						</p>

						<p>
							Il est nécessaire de donner une direction initiale à notre joueur pendant l'initialisation du programme.
							<ul>
								<li>Nord : X = 0 | Y = -1</li>
								<li>Sud : X = 0 | Y = 1</li>
								<li>Est : X = 1 | Y = 0</li>
								<li>Ouest : X = -1 | Y = 0</li>
							</ul>
							C'est ensuite a l'aide d'une matrice de rotation que nous calculons les nouvelles valeurs de la direction du joueur.
						</p>

						<pre><code>void rotate_right(t_data *data)
{
	double rot_speed = 1.5f;
	double old_dir_x = data->player.dir.x;
	data->player.dir.x = data->player.dir.x * cos(rot_speed) - data->player.dir.y * sin(rot_speed);
	data->player.dir.y = old_dir_x * sin(rot_speed) + data->player.dir.y * cos(rot_speed);
}
</code></pre>

						<div class="row">
							<div class="col-5">
								<p>
									Pour tourner à gauche il suffit simplement de donner une valeur négative à <i>rot_speed</i> (libre à vous de factoriser ces fonctions de rotation).
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/player_rotate.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration rotation du joueur avec le clavier</i></sup></center>
								</span>
							</div>
						</div

						<p>
							La direction va nous être très utile pour les déplacements. La difficulté est de garder ses mouvements relatifs à sa direction.<br>
							Par exemple, lorsque l'on veut se déplacer vers l'avant, le joueur doit avancer la où il regarde.
						</p>

						<p>
							Etant donné que valeurs de <i>dir</i> sont comprises entre -1 et 1, il suffit de multiplier une vitesse par ces valeurs et d'ajouter le résultat à la position du joueur.
						</p>

						<pre><code>move_forward(t_data *data)
{
	double move_speed = 150;

	// Calculating relative position
	t_vector2_f new_pos = {
		data->player.dir.x * move_speed, // x
		data->player.dir.y * move_speed  // y
	};

	// Adding that position to the player
	data->player.x += new_pos.x;
	data->player.y += new_pos.y;
}</code></pre>

						<p>
							De nouveau, pour reculer il faut donner une valeur négative à move_speed.
							Le fait de calculer de combien de combien le joueur va se déplacer (sans directement lui attribuer sa nouvelle position), va être très pratique pour vérifier les collisions.
						</p>


						<p>
							Voyons maintenant le dernier mouvemement possible de notre personnage, les déplacements latéraux.<br>
							Celui-ci est en réalité une combinaison de la rotation et du déplacement.<br>
							Il faut temporairement créer nouvelle direction à 90° à gauche ou à droite du personnage, et le faire avancer dans cette nouvelle direction.
						</p>

						<pre><code>void move_left(t_data *data)
{
	double move_speed = 150;

	// Caculating direction 90 degree to the left
	t_vector2_f new_dir = {
		data->player.dir.x * cos(-PI_2) - data->player.dir.y * sin(-PI_2), // PI / 2 = 90°
		data->player.dir.x * sin(-PI_2) + data->player.dir.y * cos(-PI_2)
	};

	t_vector2_f new_pos = {
		new_dir.x * move_speed,
		new_dir.y * move_speed
	};

	data->player.x += new_pos.x;
	data->player.y += new_pos.y;
}</pre></code>
						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/player_move.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration déplacements du joueur avec le clavier</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Après avoir ajouté ces fonctions dans <i>player_input</i>, nous avons désormais la possibilité de déplacer notre joueur.<br>
									Il faut cependant veiller à désormais <b>utiliser la position de notre personnage</b> dans les fonctions utilisant les rayons <b>et non plus le centre de l'écran</b>.<br>
									De plus, il ne faut pas oublier de <b>mettre à jour <i>view_dst_pos</i></b> à la fin de la fonction <i>player_input</i>.
								</p>
							</div>
						</div>

						<i>Mise à jour de view_dst_pos à la fin de la fonction "player_input"</i>
						<pre><code>data->player.view_dst_pos.x = data->player.dir.x * data->view_dst + data->player.pos.x;
data->player.view_dst_pos.y = data->player.dir.y * data->view_dst + data->player.pos.y;</code></pre>


						<p>
							Comme mentionné plus haut, il serait un peu plus réaliste de pouvoir heurter un mur au lieu de passer au travers.<br>
							Rien de bien compliqué tout est déja en place.
						</p>
						<p>
							Avant de mettre à jour les coordonées du joueur lors d'un déplacement, il faut vérifier qu'il n'aille pas sur une cellule représentant un mur dans notre tableau.
							Voici la fonction pour vérifier si une cellule est un mur, à partir de coordonnées en pixels.
						</p>

<pre><code>int is_colliding_cell(t_data *data, float x, float y)
{
	// Convert world coordinates to cell coordinates
	t_vector2_d cell = {
		x / data->cell_size,
		y / data->cell_size
	};

	// Check out of map coordinates
	if (cell.x < 0 || cell.x > data->tab_width - 1)
		return (0);
	if (cell.y < 0 || cell.y > data->tab_height - 1)
		return (0);

	// Check cell value
	if (data->tab[cell.y][cell.x] == 1) // Is a wall
		return (1);

	return (0);
}</pre></code>

						<p>Si à l'avenir notre programme devait accueillir d'autres valeurs de cellules, nous pourrons ici définir si elles sont solides ou non.</p>
						<p>Vérifier une collision est maintenant on ne peut plus simple.</p>

						<i>le code suivant est la suite de la fonction move_forward</i>
						<pre><code>t_vector2_f *p_pos = &data->player_pos; // Reference to player pos

// Check collision on X coordinate
if (!is_colliding_cell(data, p_pos->x + new_pos.x, p_pos->y))
	p_pos->x += new_pos.x;

// Check collision on Y coordinate
if (!is_colliding_cell(data, p_pos->x, p_pos->y + new_pos.y))
	p_pos->y += new_pos.y;
</code></pre>
						<div class="row">
							<div class="col-5">
								<p>Le fait de séparer la vérification des coordonées X et Y permet de ne pas être "bloqué" dès lors que le joueur se trouve près d'un mur. Au lieu de ca, le personnage va longer le mur.</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/player_collision.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration collisions</i></sup></center>
								</span>
							</div>
						</div>

						<h4>Rendu en première personne</h4>

						<p>
							Aventurons nous maintenant vers le moment le plus récompensant de ce projet.<br>
							L'intégralité de ce que nous avons dessiné à l'écran jusqu'à présent, n'est en réalité utile que pour comprendre comment fonctionne le raycasting.<br>
						 	L'affichage comme nous l'avons fait peut cependant être réutilisé pour créer une minimap, un éditeur de niveaux et une multitude d'autres ajouts.
						</p>

						<p>
							C'est grâce aux données contenues dans les rayons que nous sommes en capacité de simuler un affichage en première personne.<br>
							Notre écran sera constitué de plusieurs bandes vertcales (autant qu'il y a de rayons). Il faut dessiner sur chaque bande, un rectangle (représentant une portion de mur)
							dont la hauteur va dépendre de la distance qu'à mis le rayon à une collision.
						</p>

						<p>
							C'est donc après avoir calculé la position de l'impact des rayons (fonction <i>calculate_collisions</i>) que nous voulons afficher nos murs.<br>
							Créons une fonction nommée <i>rays_render</i> qui se chargera de ceci.
						</p>

						<p>Après avoir calculé la largeur d'une tranche, il faut itérer sur tous les rayons et vérifier que ceux-ci ont belle et bien rencontré une collision.</p>

						<pre><code>void rays_render(t_data *data)
{
	const int slice_width = data->win_width / data->rays_nb;

	for (int i = 0; i < data->rays_nb; i++)
	{
		// Reference to the current ray
		t_ray *ray = &data->rays[i];

		if (ray->length == -1) // Ray didn't hit
			continue;
	}
}</pre></code>

						<p>
							 Le coeur de cette fonction peut être divisée en 3 parties.<br>
							 <ul>
								 <li>Calculer la hauteur de la tranche</li>
								 <li>Choisir la couleur du mur</li>
								 <li>Déterminer la position du rectangle à afficher</li>
							 </ul>
						</p>

						<p>
							La hauteur de la tranche se calcul en multipliant, l'inverse de la longueur du rayon par la hauteur de l'écran.<br>
							Il est possible d'ajuster le résultat obtenu en ajoutant un coefficient comme 2 pour doubler la taille des tranches ou 0.5 pour au contraire, diviser la hauteur par 2.
						</p>

						<i>Le code suivant est la continuité de rays_render (dans la boucle for)</i>
						<pre><code>// Calculating slice height
float slice_height = 1.0f / ray->length;
slice_height = slice_height * data->win_height;
slice_height = slice_height * 2; // Make the wall two times bigger
</code></pre>

						<p>Comme mentionné dans la description de la structure <i>t_ray</i>, la couleur à afficher va dépendre de l'orientation du mur.</p>
						<pre><code>int color;
if (ray->side_hit == 0)
	color = RED;
else if (ray->side_hit == 1)
	color = BLUE;
else if (ray->side_hit == 2)
	color = YELLOW;
else
	color = GREEN;
</pre></code>

						<div class="row">
							<div class="col-6">
								<p>
									L'affichage de nos tranches, se fera depuis le milieu de l'écran. Si une tranche fait 500 pixels de hauteur, 250 pixels seront affichés vers le bas, et 250 vers le haut de l'écran.<br>
									Pour ce qui est de l'espacement horizontal, nous avons calculé <i>slice_width</i> qui va nous permettre d'espacer correctement nos tranches.
								</p>
							</div>
							<div class="col-4">
								<span class="image fit">
									<img src="images/cube3d/rays_spacing.png" alt="" />
									<center><sup><i>Schéma affichage des tranches (avec 5 rayons)</i></sup></center>
								</span>
							</div>
						</div>


						<pre><code>// Calculating top left corner position of the slice to draw
t_vector2_d tl = {
	i * slice_width, // X
	data->win_height / 2 + slice_height / 2 // Y
};

// Same for bottom right corner
t_vector2_d br = {
	i * slice_width + slice_width, // X
	data->win_height / 2 - slice_height / 2 // Y
};

draw_rect_color(data, tl, br, color);</code></pre>



						<div class="row">
							<div class="col-5">
								<p>
								Il est important que le nombre de rayons soit un multiple de la taille horizontale de la fenêtre. Etant donné qu'il n'est pas possible de dessiner sur des fractions de pixels,
								si nous avions une fenêtre de 100 pixels (de largeur) et 30 rayons, la dernière tranche de pixels serait perdue et n'afficherait rien.
							</p>
							<p>Cette possibilité d'utiliser un rayon pour plusieurs tranches, est cependant très utiles pour optimiser l'efficacité de notre programme (bien qu'au détriment d'une certaine précision).</p>
							<p>Voici le résultat obtenu lorsque nous naviguons sur la carte en première personne cette fois-ci.</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/fish_eye.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration rendu</i></sup></center>
								</span>
							</div>
						</div>

						<p>
							Sur cette vidéo, les deux moitiés de l'écran sont repeintes en bleu et gris pour donner une impression de sol et de ciel.<br>
							Ceci est effectué dans une fonction nommée <i>floor_and_ceiling</i> (non presentée sur cette page).
						</p>

						<p>Maintenant que nous possédons tous les éléments importants du raycasting, voici à quoi ressemble notre fonction <i>update</i></p>

						<pre><code>int update(t_data *data)
{
	player_input(data);

	floor_and_ceiling(data);

	create_rays(data);
	calculate_collisions(data);
	rays_render(data);

	mlx_put_image_to_window(data);
}</code></pre>


						<div class="row">
							<div class="col-5">
								<p>
									Si le rendu des murs parait étrange, c'est à cause du tant redouté "fish eye effect".<br>
									En français, "l'effet oeil de poission", apparait lorsque l'on utilise la distance euclidienne des rayons.<br>
									Le moyen de repérer cet effet, est de se mettre face à un mur. Les côtés du mur seront alors courbés d'une façon non-naturelle.
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<img src="images/cube3d/fish_eye_wall.png" alt="" />
									<center><sup><i>Rendu avec fish eye</i></sup></center>
								</span>
							</div>
						</div>

						<p>
							Les rayons en bordure du champs de vision mettent une plus grande distance à atteindre le mur, c'est pourquoi leur hauteur est moins grande comparé à celle des rayons du centre.
						</p>

						<b>SCHEMA</b>

						<p>
							Un moyen d'uniformiser cette longueur est d'utiliser un plan de caméra.<br>
							Ce plan sera perpendiculaire à la direction du joueur et se prolongera à l'infini
						</p>
						<b>SCHEMA</b>

						<p>
							Pour avoir cette distance uniformisée, il nous faut un point en plus du joueur et du hit.<br>
							Ces trois points formeront un triangle rectangle en ce nouveau point.<br>
							C'est la distance entre le hit et ce nouveau point que nous utiliserons pour afficher notre portion de mur.<br>
							Cette valeur sera stockée sous format de <i>double</i> <b>dans une nouvelle donnée de la structure t_ray, nommée <i>perp_length</i></b></p>
						</p>
						<b>SCHEMA</b>

						<p>
							Ce calcul se fera dans la DDA. La page Lode's Computer Graphics Tutorial offre un moyen très efficace pour directement calculer cette longueur.<br>
							Si le dernier axe incrémenté est l'axe horizontal, <i>perp_length</i> sera égal à :<br>
							<pre><code>ray->perp_length = (side_dist.x - delta_dist.x) * data->cell_size</code></pre>
							Autrement, perp_length prendra la valeur :<br>
							<pre><code>ray->perp_length = (side_dist.y - delta_dist.y) * data->cell_size</code></pre>
						</p>

						<div class="row">
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/fish_eye_corrected.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration rendu avec correction fish eye</i></sup></center>
								</span>
							</div>
							<div class="col-5">
								<p>
									Voici le résultat quand <i>perp_length</i> est utilisé à la place de <i>length</i> dans la fonction <i>rays_render</i>.<br>
									Le problème de fish eye est corrigé et les murs sont maintenant beaucoup plus lisses.
								</p>
							</div>
						</div>


						<h4>Utilisation de textures</h4>

						<p>
							La dernière étape de ce guide consiste à remplacer les magnifiques couleurs de nos murs par des textures.<br>
							Il est possible de convertir des images au format XPM, en données utilisables par notre programme.
						</p>

						<div class="row">
							<div class="col-5">
								<p>Voici la structure utilisée pour stocker une texture au sein de notre programme.</p>
								<p>Essayons maintenant de créer une fonction capable d'initialiser une texture à partir d'un fichier de notre PC.</p>
							</div>
							<div class="col-5">
								<pre><code>typedef s_text
{
	void *text;
	char *text_adr;
	int bits_per_pixel;
	int line_length;
	int endian;
	int width_img;
	int height_img;
} t_text;</code></pre>
							</div>
						</div>

						<p>Nous utiliserons les fonction de la MiniLibX <i>mlx_xpm_file_to_image</i> et <i>mlx_get_data_addr</i>.</p>

						<pre><code>int load_texture(t_data *data, t_texture *texture, char *texture_path)
{
	texture->text = mlx_xpm_file_to_image(data->mlx, texture_path, &texture->width_image, &texture->height_img);
	if (texture->text == NULL) // Check conversion error
		return (1);

	texture->text_adr = mlx_get_data_addr(texture->text, &texture->bits_per_pixel, &texture->line_length, &texture->endian);
	if (texture->text_adr == NULL)
		return (1);

	return (0);
}</code></pre>

						<p>
							Le paramètre <i>texture</i> correspond à l'addresse de la variable qui va stocker notre texture.<br>
							Ici nous voulons une texture pour toutes les face d'une cellule. Dans notre structure <i>data</i> se trouvera donc un tableau
							de textures (de taille 4), que nous itialiserons avec les textures que nous voulons charger .<br>
						</p>

						<p>
							Pour fidèlement projeter une image sur un mur, il est essentiel de pouvoir prévéler les pixels à une certaine position de notre texture.<br>
							La manière de faire est on ne peut plus similaire à la fonction <i>my_mlx_pixel_put</i> présentée au début.
						</p>

						<pre><code>int get_text_pixel(t_text *texture, int x, int y)
{
	int color;

	// Check out of texture coordinate
	if (x < 0 || x >= text->width_img)
		return (0); // Returning black color
	if (y < 0 || y >= text->height_img)
		return (0);

	color = (*(int *)text->text_adr + (y * text->line_length) + (x * text->bits_per_pixel / 8))
	return (color);
}</code></pre>


						<p>
							De la même manière que pour afficher une couleur sur un mur, c'est a partir d'une tranche de l'écran que nous déposerons les pixels de haut en bas.<br>
							La difficulté cette fois-ci est de savoir où sur la texture, préveler nos pixels pour les replacer sur notre mur.
						</p>

						<p>
							Commençons par trouver la coordonnée horizontale de la texture à partir de l'impact d'un rayon.<br>
							Il faut premièrement trouver la position exacte du hit. Jusqu'à présent avoir la position du hit au pixel pret était suffisant.
							Cependant si une texture fait 100 pixels de large et que <i>cell_size</i> ne fait que 50 pixels, la moitié de la texture (une colonne sur deux) passera à la trappe.
							<b>SCHEMA</b>
						</p>

						<p>Voici le bout de code permettant de calculer la position exacte de l'impact :</p>
						<pre><code>double perp_angle = PI_2 - ray->angle + get_angle_f(data->player.pos, vector_d_to_f(data->player.view_dst_pos));
double	hit_length = ray->perp_length * 0.5f * data->cell_size / sin(perp_angle);

t_vector2_f wall_x = create_vect_f_from_origin(data->player.pos, ray->angle, hit_length);</code></pre>
						<b>SCHEMA</b>

						<p>
							Il peut être nécessaire de rajouter un coefficient à <i>perp_length</i> comme il a été fait ici avec le "* 0.5f".<br>
							Ce coefficient est nécessaire car la valeur de <i>perp_length</i> change en fonction de <i>cell_size</i> et de <i>view_dst</i>.<br>
							Le code présenté utilise une <i>cell_size</i> de 40 ainsi qu'une <i>view_dst</i> de 800 pixels.
						</p>

						<p>
							A partir de cette position, il est possible de trouver la coordonnée horizontale de la texture.<br>
							Il faut pour cela trouver où notre rayon entre en collision sur la cellule.<br>
							Exemple (avec <i>cell_size</i> égal à 40):
						</p>

						<p>
							Notre rayon touche le bas de la première cellule à la coordonnée 20 sur l'axe X.<br>
							20 étant le milieu de <i>cell_size</i> on sait qu'il faudra afficher le milieu de la texture à cet endroit là.<br>
							Il faut ensuite convertir cette valeur (en pixel) en ratio entre 0 et 1 et enfin l'adapter à la taille de la texture.
						</p>

						<pre><code>int get_tex_x(t_data *data, t_ray *ray, t_texture *texture)
{
	// Calculating exact hit position
	double perp_angle = PI_2 - ray->angle + get_angle_f(data->player.pos, vector_d_to_f(data->player.view_dst_pos));
	double	hit_length = ray->perp_length * 0.5f * data->cell_size / sin(perp_angle);
	t_vector2_f wall_x = create_vect_f_from_origin(data->player.pos, ray->angle, hit_length);

	float cell_pos;
	// Getting hit position relative to the cell
	if (ray->side_hit == 1 || ray->side_hit == 3) // Horizontal hit
		cell_pos = wall_x.y - (int)(wall_x.y / data->cell_size) * data->cell_size;
	else // Vertical hit
		cell_pos = wall_x.x - (int)(wall_x.x / data->cell_size) * data->cell_size;

	if (ray->side_hit == 3 || ray->side_hit == 2) // Converting cell_pos to ratio
		cell_pos = cell_pos / data->cell_size;
	else // Flip texture if the side hit is the top or the right side of a cell
		cell_pos = 1.0f - cell_pos / data->cell_size;

	int tex_x = cell_pos * texture->width_img; // Mapping ratio to texture dimension

	return (tex_x);
}</code></pre>

						<p>
							Il est important de retourner les textures affichées en le haut et à droite des cellules. Autrement celles-ci s'afficheront de manière inversée.
						</p>


						<p>
							La difficulté à présent est d'afficher à l'échelle de notre portion de mur, une bande de la texture.<br>
							Si la hauteur de notre portion de mur est supérieure à la hauteur de la texture, cela veut dire qu'il faudra étirer la texture en hauteur pour pouvoir remplir toute la zone.<br>
							A l'inverse, si notre portion est moins haute, il faudra "écraser" la texture pour que celle-ci puisse être entièrement affichée.
						</p>

						<div class="row">
							<div class="col-4">
								<span class="image fit">
									<img src="images/cube3d/stretch0.png" alt="" />
									<center><sup><i>Texture de base</i></sup></center>
								</span>
							</div>
							<div class="col-4">
								<span class="image fit">
									<img src="images/cube3d/stretch1.png" alt="" />
									<center><sup><i>Texture étirée</i></sup></center>
								</span>
							</div>
							<div class="col-4">
								<span class="image fit">
									<img src="images/cube3d/stretch2.png" alt="" />
									<center><sup><i>Texture écrasée</i></sup></center>
								</span>
							</div>
						</div>

						<p>Bien sûr ce changement d'échelle dépendra de l'orientation du joueur par rapport au mur. C'est d'ailleurs celui-ci qui va rendre l'incrustation de la texture naturelle.</p>

						<div class="row">
							<div class="col-6">
								<span class="image fit">
									<img src="images/cube3d/no_texture.png" alt="" />
									<center><sup><i>Mur sans texture</i></sup></center>
								</span>
							</div>
							<div class="col-6">
								<span class="image fit">
									<img src="images/cube3d/texture.png" alt="" />
									<center><sup><i>Mur avec texture</i></sup></center>
								</span>
							</div>
						</div>

						<p>
							Pour trouver le pas permettant d'afficher à l'échelle une texture, il suffit de diviser la hauteur de la texture par la hauteur de notre portion de mur.<br>
							Il ne reste alors qu'à partir de haut en bas la portion de mur et d'y déposer les pixels de la texture.
						</p>

						<pre><code>void rays_render(t_data *data)
{
	const int slice_width = data->win_width / data->rays_nb;

	for (int i = 0; i < data->rays_nb; i++)
	{
		t_ray *ray = &data->rays[i];

		if (ray->length == -1)
			continue;

		float slice_height = (float)(data->win_height / ray->perp_length);
		t_vector2_d tl = {i * slice_width, data->win_height / 2 + slice_height / 2};
		t_vector2_d br = {i * slice_width + slice_width, data->win_height / 2 - slice_height / 2};

		t_text *texture = &data->textures[rays->side_hit]; // Reference to the texture according on side_hit

		int tex_x = get_tex_x(data, ray, texture);
		double tex_y = 0;

		double step = texture->height_img / data->slice_height;

		for (int y = tl.y; y < br.y, y++)
		{
			if (y >= 0 && y < data->win_height)
			{
				int color = get_text_pixel(texture, tex_x, tex_y);

				for (int x = tl.x; x > br.x; x++)
					my_mlx_pixel_put(data, x, y, color);
			}
			tex_y += step;
		}
	}
}</pre></code>

						<div class="row">
							<div class="col-5">
								<p>
									Voici l'entièreté de la fonction <i>rays_render</i>, reprenant le code montré précédemment ainsi que la partie texture.<br>
									La dernière boucle <i>for</i> permet de remplir dans la largeur de chaque portion de mur. Cette partie du code est essentielle
									si il y a moins de rayons que de pixels en largeur sur la fenêtre.
								</p>
								<p>
									Voici le résultat avec des textures provenant du jeu provenant du jeu Wolfenstein 3D.
								</p>
							</div>
							<div class="col-5">
								<span class="image fit">
									<video controls width="100%">
										<source src="images/cube3d/textures.mp4" type="video/webm">
									</video>
									<center><sup><i>démonstration du rendu avec textures</i></sup></center>
								</span>
							</div>
						</div>

						<hr>


						<hr>
						<h2>Conclusion</h2>
						<hr>

						<h2 id="sources">Sources</h2>
						<h2>Téléchargement</h2>
						<!-- petite liste de 2 colonnes avec les icone de github et itch-->
						<ul class="actions">
						<li><a href="https://github.com/B-Bischoff/Ecosystem" class="button icon brands fa-github">Code source</a></li>
						<li><a href="https://b-bischoff.itch.io/ecosystem" class="button icon brands fa-itch-io">Exécutable</a></li>
						</ul>
					</div>
				</div>

				<!-- Footer -->
				<footer id="footer">
					<div class="inner">
						<ul class="copyright">
							<li>Design adapté depuis une création : <a href="http://html5up.net">HTML5 UP</a></li>
						</ul>
					</div>
				</footer>

		</div>

	<!-- Scripts -->
		<script src="assets/js/jquery.min.js"></script>
		<script src="assets/js/browser.min.js"></script>
		<script src="assets/js/breakpoints.min.js"></script>
		<script src="assets/js/util.js"></script>
		<script src="assets/js/main.js"></script>

	</body>
</html>
