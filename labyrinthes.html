<!DOCTYPE HTML>
<!--
Phantom by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
<head>
	<title>Labyrinthes</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">
	<!-- Wrapper -->
	<div id="wrapper">

		<!-- Header -->
		<header id="header">
			<div class="inner">

				<!-- Logo -->
				<a href="index.html" class="logo">
					<span class="symbol"><img src="images/Square-grey.png" alt="" /></span><span class="title">Page principale</span>
				</a>

				<!-- Nav -->
				<nav>
					<ul>
						<li><a href="#menu">Menu</a></li>
					</ul>
				</nav>

			</div>
		</header>

		<!-- Menu -->
		<nav id="menu">
			<h2>Menu</h2>
			<ul>
				<li><a href="index.html">Projets</a></li>
				<li><a href="a-propos.html">A propos</a></li>
				<li><a href="contact.html">Contact</a></li>
			</ul>
		</nav>

		<!-- Main -->
		<div id="main">
			<div class="inner">
				<h1>Labyrinthes</h1>
				<span class="image main"><img src="images/Maze/11.png" alt="" /></span>

				<h2>Contexte</h2>


				<hr>

				<h2>Réalisation</h2>
				<br>
				<h3>Concepts</h3>
				<h4>Définition d'un labyrinthe</h4>
				<span class="image right"><img src="images/Maze/perfect_maze.png" alt="" /><center><sup><i>Labyrinthe parfait</i><sup></center>
				<img src="images/Maze/imperfect_maze.png" alt="" /><center><sup><i>Labyrinthe imparfait</i><sup></center></span>
				<p>
					D'après Wikipedia, "Un labyrinthe est un tracé sinueux, muni ou non d'embranchements, d'impasses et de fausses pistes destiné à perdre ou ralentir celui qui cherche à s'y déplacer."
					<br>Il y a cependant quelques règles à respecter pour qu'un labyrinthe soit dit "parfait".<br>
					Chaque cellule du labyrinthe doit être réliée aux autres et ce, par un chemin unique (on parle de surface connexe).
					Il ne doit ainsi pas y a avoir de boucles ou de zone fermée. <br>
				</p>
				<p>Il existe de nombreuses méthodes pour créer un labyrinthe, une des plus commune est la génération par "suppression de murs"<br>
					On part d'une zone remplie de murs. Toutes ces zones entourées de murs seront appelés cellules.<br>
					L'objectif est de relier ces cellules en supprimant les murs entre elles, afin de recréer cette impression de dédale.
				</p>

				<h4>Cellule</h4>
				<p>
					Dans sa forme la plus simple, une cellule est composée de murs (quatre pour une cellule de forme carrée) et d'une position.<br>
					Sa position possède une coordonée X (axe des abscisses) et Y (axe des ordonnées). Cette position permet de la différencier parmi les autres cellules qui peuvent l'entourer.<br>
					Nous verrons que certaines méthodes de création demandent à ce que les cellules possèdent des informations supplémentaires.<br>
					Comme une valeur indiquant si cette cellule a été visitée ou bien une donnée séparant les cellules en sous-zones du labyrinthe.
				</p>



				<blockquote>
					<p><b>Précisions techniques</b><br></p>
					<p>Le code suivant montre la représentation informatique d'une cellule.<br></p>
						<pre><code>1  public class MazeCell
2  {
3  	public GameObject[] walls;
4  	public int x, y;
5
6  	public MazeCell(int x, int y)
7  	{
8  		this.x = x;
9  		this.y = y;
10 	}
11 }</code></pre>
					On retrouve les entiers X et Y correspondant à la coordonée de la cellule.<br>
					La taille du tableau <i>walls</i> sera fixé et son contenu rempli pendant la génération d'un tableau rempli de cellules.<br>
					L'utilisation de classe rend le concept de cellule extrement modulable. Pour chaque méthode de génération, nous pourrons créer une classe héritant de <i>MazeCell</i> et ainsi n'avoir que les données dont nous avons besoin.
				</blockquote>

				<p>
					Maintenant que nous possédons notre cellule sous forme de préfab, nous pouvons à l'aide d'une longueur et d'une largeur, faire apparaitre nos cellules.<br>
					Il faut pour cela, parcourir chaque case de la coordonée [0, 0] à la coordonée [longueur - 1, largeur - 1] (-1, car on compte depuis 0).
				</p>

				<h4>Tableau de cellules</h4>
				<p>
					C'est grâce à ces cellules, qui, une fois stockées dans un tableau en deux dimensions, permettent de représenter informatiquement un labyrinthe
				</p>
				<span class="image right"><img src="images/Maze/topview_5x5.png" alt="" /><center><sup><i>Labyrinthe vu de dessus</i><sup></center></span>
				<span class="image right"><img src="images/Maze/2d_array_coord.png" alt="" /><center><sup><i>Tableau deux dimensions</i><sup></center></span>
				<p>
					Dans le cas d'un labyrinthe avec des cellules carrés, on voit de manière nette la relation entre le labyrinthe et sa représentation en tableau deux dimensions.
					<br>
				</p>
				<p>
					Habituellement, la coordonée [0, 0] des tableaux en deux dimensions se situent en haut à gauche.<br>
					Afin de simplifier le placement de nos cellules dans l'espaces, la coordonée [0, 0] se trouvera en bas à gauche du tableau.<br>
					Il sera ainsi plus aisé de convertir les coordonées des cellules (deux dimensions) dans l'espace (trois dimensions).
					<br>
				</p>
				<span class="image left"><img src="images/Maze/unity_coordinate_system.png" alt="" /><sup><i>Repère orthonormé de Unity</i><sup></span>
				<span class="image right"><img src="images/Maze/maze_cell.png" alt="" /><center><sup><i>Prefab de cellule</i><sup></center></span>
				<p>
					Maintenant que nous savons comment sont stockées nos cellules dans un tableau, nous pouvons essayer de les placer dans l'espace.<br>
					Le plus simple est d'utiliser les "Unity's Prefab" https://docs.unity3d.com/Manual/Prefabs.html qui nous permettent de créer et configurer à l'avance,
					un objet que nous pourrons réutiliser pendant l'éxecution du programme.<br>
					Voici donc le prefab, de notre cellule carrée.
				</p>
				<p>
					D'après notre tableau deux dimensions, l'espacement entre chaque cellule est de 1 (sur l'axe X et Y), chaque cellule devrait donc faire une taille de 1 par 1.<br>
					<b>Illustrer avec cellule + grid dans menu prefab</b>
					Cependant, lorsque l'on crée un labyrinthe avec ces dimensions, certaines paroies possèdent des angles peu esthétique.(cf photo)<br>
					Passer la taille des murs à 1,1 nous permet de résoudre ce problème. Les murs des cellules voisines seront désormais superposés.<br>
					Cela ne pose pas de problème mais nous verrons comment les supprimer, dans le but d'optimiser les performances du programme.<br>
				</p>

				<p>
					Maintenant que nous possédons notre cellule sous forme de préfab, nous pouvons à l'aide d'une longueur et d'une largeur, faire apparaitre nos cellules.<br>
					Il faut pour cela, parcourir chaque case de la coordonée [0, 0] à la coordonée [longueur - 1, largeur - 1] (-1, car on compte depuis 0).
				</p>


				<blockquote>
					<p><b>Précisions techniques</b><br></p>
					<p>
						Voici le code permettant de créer un espace remplie de cellules.
						<pre><code>1  MazeCell[,] maze;
2  GameObject cell_prefab;
3  int height, width;
4
5  maze = new MazeCell[height, width];
6
7  for(int y = 0; y < height; y++)
8  {
9 	for (int x = 0; x < width; x++)
10	{
11		maze[y, x] = new MazeCell(y, x);
12		Vector3 position = new Vector3(y, 0, x);
13		GameObject cell = Instantiate(cell_prefab, position, Quaternion.identity);
14
15		cell.walls = new GameObject[4];
16		maze[y, x].walls[0] = cell.transform.Find("TopWall").gameObject;
17		maze[y, x].walls[1] = cell.transform.Find("LeftWall").gameObject;
18		maze[y, x].walls[2] = cell.transform.Find("BottomWall").gameObject;
19		maze[y, x].walls[3] = cell.transform.Find("RightWall").gameObject;
21	}
22 }					</pre></code>
						A l'aide de la commande <i>Instantiate</i> de Unity, ce code nous permet de créer dans l'espace une cellule pour chaque case de notre tableau deux dimensions mais également de l'initialiser pour lui donner ses valeurs.
					</p>
					<span class="image"><img src="images/Maze/topview_5x10.png" alt="" /><center><sup><i>Labyrinthe rempli de mur</i><sup></center></span>
				</blockquote>

				<h4>Suppression de murs entre cellules</h4>
				<span class="image right"><img src="images/Maze/wall_connexion.png" alt="" /><center><sup><i>cellules voisines</i><sup></center></span>
				<p>
					Voyons maintenant comment relier deux cellules voisines.<br>
					Relier veut en réaliter dire, supprimer les murs qui séparents ces cellules.<br>
					Dans l'exemple suivant, nous voulons relier ces cellules voisines horizontalement. Pour ce faire, il faut supprimer le mur de droite de la cellule A et le mur gauche de la cellule B.
					<br>
				</p>
				<blockquote>
					<p><b>Précisions techniques</b><br></p>
					<p>
						Pour nous simplifier la vie, faisons une fonction qui relie deux cellules voisines.<br>
						L'objectif est de supprimer le mur de chaque cellule en fonction de la position de son voisin.
						<pre><code>1  void LinkNeighbors(MazeCell cell_1, MazeCell cell_2)
2  {
3  	Vector2 dir = new Vector2(cell_1.x - cell_2.x, cell_1.y - cell_2.y);
4
5  	if (dir.y == -1)
6		DestroyWalls(cell_1.TopWall, cell_2.BottomWall);
7  	else if (dir.y == 1)
8  		DestroyWalls(cell_1.BottomWall, cell_2.TopWall);
9 	else if (dir.x == -1)
10		DestroyWalls(cell_1.RightWall, cell_2.LeftWall);
11	else
12		DestroyWalls(cell_1.LeftWall, cell_2.RightWall);
13 }
14
15 void DestroyWalls(GameObject wall_1, GameObject wall_2)
16 {
17 	Destroy(wall_1);
18 	Destroy(wall_2);
19 }					</pre></code>
						C'est à l'aide de la variable <i>dir</i> que nous pouvons savoir comment sont situées nos deux cellules.<br>
						En fonction de cette information, il ne reste plus qu'à supprimer les murs des cellules avec la fonction <i>Destroy</i> de Unity.
						<b>SCHEMA ILLUSTRANT CALCUL DE POSITION DES CELLULES</b>
					</p>
				</blockquote>

				<h4>Suppresion des murs superposés</h4>
				<p>
					Une fois le labyrinthe généré, nous pouvons supprimer les murs superposés restant.<br>
					Cela permet premièrement d'optimiser le programme (il y a moins d'entités à gérer) mais également d'éliminer certains "bugs" visuel où la texture d'un mur se confond celle du mur superposé.
					<br><b>PHOTO GLITCH + PHOTO PERFS</b>
				</p>
				<blockquote>
					<p><b>Précisions techniques</b><br></p>
					<p>
						<pre><code>1  for (int y = 0; y < height; y++)
2  {
3	for (int x = 0; x < width; x++)
4	{
5		if (x < width - 1 && _maze[y, x].RightWall != null && _maze[y, x + 1].LeftWall != null)
6			Destroy(_maze[y, x].RightWall);
7		if (y < height - 1 && _maze[y, x].TopWall != null && _maze[y + 1, x].BottomWall != null)
8			Destroy(_maze[y, x].TopWall
9	}
10  }</pre></code>
						Pour chaque cellule, on vérifie qu'elle ne soit pas en bordure basse ou droite du labyrinthe (afin de ne pas ouvrir le labyrinthe).<br>
						Si cette cellule possède un mur droit et que la cellule à sa droite possède un mur gauche. On supprime le mur droit de la cellule actuelle.<br>
						Le processus est le même pour le mur du bas. Si la cellule scrutée et celle du dessous possèdent leurs murs voisins, on supprime le mur bas de la cellule actuelle.
					</p>
				</blockquote>

				<p>
					Voici donc tous les concepts nécessaires pour créer un labyrinthe.<br>
					Avant de présenter les algorithmes de génération, voici une section montrant birèvement, comment ces concepts peuvent être réutilisées afin de créer des labyrinthes à cellules hexagonales regulières.<br>
				</p>

				<h4>Cellules hexagonales</h4>

				<p>Un hexagone est un polygone à six sommets et six faces. On retrouve généralement cette forme géométrique sous deux orientations :</p>
				<div class="row">
					<div class="col-6">
						<span class="image left"><img src="images/Ecosysteme/tree.png" alt="" /><center><sup><i>Hexagone pointy</i></center></sup></span>
					</div>
					<div class="col-6">
						<span class="image left"><img src="images/Ecosysteme/carrot.png" alt="" /><center><sup><i>Hexagone flat</i></center></sup></span>
					</div>
				</div>

				<p>
					La seule différence avec la celulle carrée est le nombre de murs.<br>
					La classe précédemment définie reste correcte, la seule chose à modifier est l'attribution des murs de la cellule.
				<p>

				<p>
					La dernière question à nous poser est comment peut-on représenter une grille hexagonale dans un tableau en deux dimensions ?<br>
					De nombreuses représentations existent déjà avec chacune des avantages et inconvénients.<br>
					La solution choisie est d'utiliser la même méthode que pour les cellules carrées. C'est une représentation simple à mettre en place,
					cependant, elle s'avère peu pratique lorsque l'on souhaite relier des cellules entre elles.<br>
				</p>

				<blockquote>
					<p><b>Précisions techniques</b><br></p>
					<p>
						Voici la première difficultée des grilles hexagonales. Selon l'orientation de l'hexagone, une cellule sur deux sera décalée.<br>
						<b>PHOTOS ILLUSTRANT DECALAGE POUR POINT ET FLAT</b><br>
						Ce choix de représentation nous force donc à différencier les opérations, en fonction de l'orientation de l'hexagone.<br>
						Voici d'ailleurs un schéma illustrant comment sont situés les hexagones voisins à une cellule, en fonction de son orientation, mais également de son décalage précédemment mentionné.
						<br>
						<b>REPRESENTATION VOISINS CELLULES HEXAGONALES</b>
					</p>
				</blockquote>

				<h3>Algorithmes</h3>

				<p>
					Voici une sélection de plusieurs méthodes de génération.<br>
					Chacune possède ses avantages et ses inconvénients.<br>
				</p>

				<h4>Backtracker</h4>

				<p>
					Probablement l'une des plus répandues (car l'une des plus simples), la méthode du backtracker (ou retour arrière en français) permet de systématiquement tester l'ensemble des décisions possibles.
					<br>
					Cette famille d'algorithmes est utilisée pour résoudre des problèmes algorithmiques comme de l'optimisation combinatoire ou des jeux, telle que le problème des dix dames <b>LIEN</b> ou la résolution de sudoku.
				</p>
				<p>
					Appliqué à nos labyrinthe, en partant d'une grille remplie de murs, cette méthode a pour objectif de créer un chemin, en passant par toutes les cellules de notre labyrinthe.
					<br>
					De manière plus détaillée :<br>
					Chaque cellule du tableau possède un état visitée ou non (initialement mis à non-visitée). Depuis une cellule de départ, le programme va se déplacer aléatoirement sur une cellule non-visitée, voisine à la sienne (et définir son état comme visitée).
					<br>
					Dès lors que celle-ci ne possède plus de cellules voisines non-visitées, le programme revient sur ses pas jusqu'à en retrouver.
					<br>
					Si il n'en trouve plus, cela veut dire qu'il a testé toutes les possibilitées.
				</p>

				<p>
					Pour garder en mémoire les déplacements effectués, nous stockerons les cellules visitées dans une pile<b>LIEN PILE</b> (une structure de donnée informatique).
					<b>Représentation pile</b>
				</p>

				<p>Algorithme :</p>
					<pre><code>- Choisir une cellule, la marquer comme visitée et l'ajouter à la pile
- Tant que la pile n'est pas vide
    - Prendre la cellule au sommet de la pile et la considérer comme la cellule actuelle
    - Si la cellule actuelle possède au moins un voisin "non-visité"
        - Mettre la cellule actuelle au sommet de la pile
        - Choisir une des cellules voisines non-visitée
        - Relier la cellule actuelle à la cellule voisine
        - Définir la cellule voisine comme visitée et la mettre au sommet de la pile</pre></code>

				<p><b>GIF MAZE GENERATING + GIF THEORIE</b></p>

				<p>
					Cette méthode est extrêmement simple à implémenter et efficace. Elle peut cependant se révéler gourmande en stockage dû à la pile qui augmente en fonction de la taille du labyrinthe à générer.<br>
					De plus, le résultat se retrouve quelques fois non pas "labyrinthique" mais juste comme un long chemin tortueux, avec que peu d'embranchements. Ceci s'explique par le fait que la méthode explore aussi loin que possible chaque
					possibilitées, avant de revenir sur ses pas.
				</p>

				<h4>Kruskal</h4>

				<p>
					L'algorithme de Kruskal est initialement appliqué dans le domaine des graphes.<br>
					Il permet de rechercher un arbre recouvrant le poids minimum dans un graphe.<br>
					Une des applications concrètes que l'on pourrait lui trouver, serait de simplifier un câblage ou bien
					de supprimer les chemins de transports les moins rentables.
				</p>

				<p>
					Cette méthode est une version aléatoirisée de l'algorithme d'origine.<br>
					Initialement la méthode séléctionne <a href="https://fr.wikipedia.org/wiki/Ar%C3%AAte_(th%C3%A9orie_des_graphes)#:~:text=En%20th%C3%A9orie%20des%20graphes%2C%20une,appel%C3%A9%20ar%C3%AAte%20orient%C3%A9e%20ou%20arc">
					<i>les arêtes</i></a> d'un graphe par poids croissant.<br>
					Or ici, elles seront séléctionnées de manière aléatoire.
				</p>

				<b>GIF KRUSKAL DANS UN GRAPH</b>

				<p>
					Plus concrètement, à partir d'un labyrinthe rempli de murs, chaque cellule possèdera un set (un identifiant unique).<br>
					L'objectif est de relier les cellules de sets différents et d'appliquer un set commun aux cellules réliées.
				</p>

				<p>Algorithme :</p>
					<pre><code>- Tant que toutes les cellules n'ont pas le même set
	- Prendre deux cellules voisines avec un set différent
	- Relier ces deux cellules
	- Choisir un des deux set et l'appliquer à toutes les cellules du set opposé</pre></code>

				<p>
					Cet méthode est plutôt simple et direct. Elle peut cependant se révéler couteuse, notamment lorsqu'il faut changer le set d'un groupe de cellules.<br>
					La manière la plus simple est d'itérer sur toutes les cellules du labyrinthe. Il est cependant possible d'utiliser des listes chainées ou d'autres structures de données pour isoler les sets
					afin d'alléger cette opération.
				</p>

				<p>Dans sa finalité, l'algorithm de Kruskal créé de nombreuses impasses peu profondes.

				<h4>Prim</h4>

				<p>
					La méthode de Prim a de nombreuses ressemblances à celle de Kruskal, son objectif est similaire, mais la manière de l'atteindre est fondamentalement différente.<br>
					Cet algorithme permet également de trouver un arbre recouvrant le poids minimum dans un graphe.<br>
					Là où la méthode de Kruskal sélectionne les arrêtes de poids faibles dans tout le graphe, Prim va, depuit un point de départ, faire croître un abre en sélectionnant les arêtes
					de poids faibles incidentes à cet arbre.
				</p>

				<b>GIF PRIM DANS UN GRAPH</b>

				<p>
					Encore une fois, cette méthode est aléatoirisée par rapport à l'algorithme d'origine.<br>
					Au lieu de choisir l'arête la plus faible, elle sera choisie de manière aléatoire.
				</p>

				<p>
					Pour appliquer ce concept à nos labyrinthes, il va falloir garder en mémoire : <br>
					Premièrement, les cellules visitées<br>
					Et ensuite, les cellules voisines des cellules visitées (que nous appelerons les cellules "en bordure")
				</p>

				<p>
					A partir d'une cellule de départ, le programme va relier une cellule en bordure à une cellule visitée.<br>
					Cela aura pour effet de faire croître une "zone" qui va créer notre labyrinthe en supprimant les murs de manière aléatoire.
				</p>

				<p>Algorithme :</p>
					<pre><code>- Choisir une cellule de départ et noter cette cellule comme visitée
- Noter ses cellules voisines comme bordure
- Tant qu'il existe des cellules en bordure
	- Choisir aléatoirement une des cellules en bordures
	- La relier à une cellule visitée voisine
	- Noter cette cellule comme visitée et marquer ses voisins (non-visités) comme bordure</pre></code>


				<p>
					Sans grande surprise, le résultat est similaire à celui de Kruskal.<br>
					Le labyrinthe possède ici aussi de nombreuses impasses peu profondes.<br>
				</p>

				<h4>Divisions récursives</h4>

				<p>
					Pour la première fois, nous partirons d'un labyrinthe sans murs à l'intérieurx !<br>
					Cette méthode consiste à découper notre labyrinthe en une multitude de salle (que l'on appelera "chambre").<br>
				</p>

				<p>
					Le concept et son implémentation sont on ne peut plus simple.<br>
					Il faut diviser chaque chambre en quatre à l'aide de murs. Pour que les nouvelles chambres ne soient pas inaccessibles, il faut veiller à laisser un passage dans les murs créés.
				</p>
				<b>GIF DU PRINCIPE</b>

				<p>
					Il est possible de rendre le résultat un peu plus intéressant en divisant les chambres, non plus au milieu, mais de manière aléatoire.
				</p>
				<b>GIF MURS ALEATOIRES</b>

				<p>Algorithme :</p>
					<pre><code>- Depuis la chambre initiale, créer deux murs perpendiculaires (de sorte à créer 4 sous-chambres)
- Créer un passage dans trois des quatre murs
- Tant qu'il est possible de diviser une sous-chambre
	- Répéter ce processus pour chaque sous-chambre</pre></code>

				<p>
					Le style de ce labyrinthe est extrêmement différent de ceux vues précédemment<br>
					Cette méthode a tendance à crééer de longs couloirs ce qui rend la résolution du labyrinthe plus simple.<br><br>
					Ce concept si simple, peut être légèrement modifié pour obtenir d'autres résultats.<br>
					Il est par exemple possible de mettre une limite de recursivité afin d'obtenir des salles plus grandes.<br>
					<b>PHOTOS</b>
				</p>



				<h4>Divisions récursives améliorées</h4>

				<hr>

				<h2>Conclusion</h2>

				<h3>Améliorations possibles</h3>

				<hr>
				<h2>Sources</h2>

				<hr>
				<h2>Téléchargement</h2>
				<!-- petite liste de 2 collones avec les icone de github et itch-->
				<ul class="actions">
				<li><a href="#" class="button icon brands fa-github">Code source</a></li>
				<li><a href="#" class="button icon brands fa-itch-io">Exécutable</a></li>
			</ul>
			</div>
		</div>

		<!-- Footer -->
		<footer id="footer">
			<div class="inner">
				<ul class="copyright">
					<li>Design adapté depuis une création : <a href="http://html5up.net">HTML5 UP</a></li>
				</ul>
			</div>
		</footer>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>

	</body>
</html>
